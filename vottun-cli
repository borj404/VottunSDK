#!/bin/bash

APP_ID="HERE YOUR APP ID"
API_KEY="HERE YOUR API KEY"
email="HERE YOUR EMAIL" # ONLY REQUIRED TO USE CUSTODIED WALLETS FUNCTIONS

cat << banner

░░░░░░░██╗░█████╗░████████████████╗██╗░░░░░░███╗░░██╗  ░█▀▀█ ▒█▀▀█ ▀█▀ █▀▀
██╗░░░██╔╝██╔══██╗╚══██╔═════██╔══╝██║░░░██╗████╗░██║  ▒█▄▄█ ▒█▄▄█ ▒█░ ▀▀█
╚██╗░██╔╝░██║░░██║░░░██║░░░░░██║░░░██║░░░██║██╔██╗██║  ▒█░▒█ ▒█░░░ ▄█▄ ▀▀▀
░╚████╔╝░░██║░░██║░░░██║░░░░░██║░░░██║░░░██║██║╚████║
░░╚██╔╝░░░╚█████╔╝░░░██║░░░░░██║░░░╚██████╔╝██║░╚███║        Version 0.5.1
░░░╚═╝░░░░░╚════╝░░░░╚═╝░░░░░╚═╝░░░░╚═════╝░╚═╝░░╚══╝ Scripted by @borj404

banner

help(){ # HELP MENU

cat << menu

Type the function and fill in the required parameters
Press ⏎ after each prompt to continue
To undo the previous entry type << , .. , !undo , !back or !del
"All parameter inputs are handled dynamically, so you must NOT quote strings, even in arrays"
(Optional parameters are indicated in parentheses)
All token amounts must be entered in standard units, not in wei as stated in the docs

For detailed information about this APIs, visit: https://docs.vottun.io/

❮❮❮ AVAILABLE FUNCTIONS ❯❯❯

IPFS
~$ up_file ―▸ Upload a binary file to IPFS
~$ up_folder ―▸ Upload a folder or zip with multiple files to IPFS
~$ up_metadata ―▸ Upload a JSON file to IPFS

ERC-20
~$ deploy20 ―▸ Deploy an ERC-20 smart contract
~$ transfer20 ―▸ Transfer tokens to an address
~$ transfer_from ―▸ Transfer tokens from a sender's account to a receiver's address
~$ incr_allowance ―▸ Grant a spender account the right to manage a specified amount of tokens
~$ decr_allowance ―▸ Revoke a spender account the right to manage a specified amount of tokens
~$ allowance ―▸ Display the total amount of tokens the owner has authorized the spender to transact
~$ name ―▸ Display the name of a smart contract
~$ symbol ―▸ Display the symbol of a smart contract
~$ supply ―▸ Display the total supply of tokens created in an ERC-20 smart contract
~$ decimals ―▸ Display the decimals used for tokens in an ERC-20 smart contract
~$ balance20 ―▸ Display the balance of tokens held by an address

ERC-721
~$ deploy721 ―▸ Deploy an ERC-721 smart contract
~$ mint721 ―▸ Mint an NFT with the provided metadata to the specified address
~$ transfer721 ―▸ Transfer an NFT to an address
~$ balance721 ―▸ Display the NFT balance of an address in the specified smart contract and network
~$ uri721 ―▸ Display the metadata URI for an NFT in the specified contract
~$ owner ―▸ Display the address of the owner of an NFT

ERC-1155
~$ deploy1155 ―▸ Deploy an ERC-1155 smart contract
~$ mint1155 ―▸ Mint the specified amount of copies of an NFT with the provided metadata to the given address
~$ mint_batch ―▸ Mint the specified amount of copies of multiple NFTs with the provided metadata to the given address
~$ transfer1155 ―▸ Transfer the specified amount of copies of an NFT to the given address
~$ transfer_batch ―▸ Transfer the specified amount of copies of multiple NFTs to the given address
~$ balance1155 ―▸ Display the amount of an NFT for the given address and smart contract on a specified network
~$ uri1155 ―▸ Display the URI of the metadata for the NFT from the given contract

POAP
~$ deployPOAP ―▸ Deploy a POAP smart contract and mint the tokens
~$ transferPOAP ―▸ Transfer an NFT to the given address
~$ balancePOAP ―▸ Display the amount of an NFT for the given address and smart contract on a specified network
~$ uriPOAP ―▸ Display the URI of the metadata for the NFT from the given contract

CUSTODIED WALLETS
~$ new_wallet ―▸ Generates a one-time-use hash and retrieves the URL to create a new custodied wallet
~$ get_address ―▸ Retrieve the wallet's public address (for the 1st account) for one of our users
~$ get_wallets ―▸ Retrieve all custodied wallets created for you
~$ otp ―▸ Request a one-time email OTP to sign a mutable transaction within the next 120 seconds
~$ send_tx ―▸ Call any public function implemented in a smart contract and modify its state (for view or pure functions, use "query")
~$ send_nat ―▸ Transfer native assets from your custodied wallet

WEB3 CORE
~$ deploy ―▸ Deploy a smart contract on the blockchain of your choice
~$ call_function ―▸ Call any public function implemented in a smart contract and modify its state (for view or pure functions, use "query")
~$ query ―▸ Call any public function implemented in a smart contract without change its state (view or pure functions)
~$ get_nets ―▸ Request the list of available blockchain networks
~$ get_specs ―▸ Request the list of available contract specifications
~$ query_address ―▸ Query an address to determine if it is a smart contract
~$ query_tx ―▸ Query transaction information from the blockchain
~$ query_status ―▸ Query the status of a transaction
~$ query_ref ―▸ Query the status of a transaction using the customer reference
~$ query_gas ―▸ Query the current gas price for a specified blockchain network
~$ query_nat ―▸ Query the balance of native currency for a specified address
~$ gas_deploy ―▸ Estimate the gas required for a smart contract deployment
~$ gas_tx ―▸ Estimate the gas required to call any public function implemented in a smart contract
~$ gas_nat ―▸ Estimate the gas required to transfer native assets

menu
}

auth=("--header" "x-application-vkn: $APP_ID" "--header" "Authorization: Bearer $API_KEY")
ct_json="--header 'Content-Type: application/json'"

_check_input() {
    local prompt="$1"
    local var_name="$2"
    local undo_step="$3"
    local required="$4"
    local validate_cmd="$5"
    local empty_err="$6"
    local format_err="$7"
    
    while true; do
        read -e -p "$prompt" input
        
        if [[ "$input" =~ ^(<<|\.\.|!undo|!back|!del)$ ]]; then
            if [[ "$undo_step" -ne -1 ]]; then
                return 99
            else
                echo "Nothing to undo!"
                continue
            fi
        fi

        if [[ "$required" == "true" && -z "$input" ]]; then
            echo "Error: $empty_err"
        elif [ -n "$input" ] && ! eval "$validate_cmd"; then
            echo "Error: $format_err"
        else
            eval "$var_name=\"\$input\""
            return 0
        fi
    done
}

_step_back() {
    [[ $? -eq 99 ]] && step=$((step - 1))
}

_confirmation() {
    while true; do
        read -e -p "Do you want to proceed with these parameters? (Y/N): " confirm
        [[ "$confirm" =~ ^(<<|\.\.|!undo|!back|!del)$ ]] && return 99
        case "$confirm" in
            [Yy]*)
                echo
                return 0
                ;;
            [Nn]*)
                echo
                echo "Process cancelled."
                return 1
                ;;
            *)
                echo "Invalid input! Try again..."
                ;;
        esac
    done
}

_network_details() {

    local network=$1 net_name currency url_address url_tx
    currency="ETH"

    case $network in
        # TESTNET
        11155111)
            net_name="Ethereum Sepolia"
            url_address="https://sepolia.etherscan.io/address/"
            url_tx="https://sepolia.etherscan.io/tx/"
            ;;
        421614)
            net_name="Arbitrum Sepolia"
            url_address="https://sepolia.arbiscan.io/address/"
            url_tx="https://sepolia.arbiscan.io/tx/"
            ;;
        84532)
            net_name="Base Sepolia"
            url_address="https://sepolia.basescan.org/address/"
            url_tx="https://sepolia.basescan.org/tx/"
            ;;
        97)
            net_name="BNB Smart Chain Testnet"
            currency="BNB"
            url_address="https://testnet.bscscan.com/address/"
            url_tx="https://testnet.bscscan.com/tx/"
            ;;
        80002)
            net_name="Polygon Amoy"
            currency="POL"
            url_address="https://amoy.polygonscan.com/address/"
            url_tx="https://amoy.polygonscan.com/tx/"
            ;;
        43113)
            net_name="Avalanche Fuji"
            currency="AVAX"
            url_address="https://43113.testnet.snowtrace.io/address/"
            url_tx="https://43113.testnet.snowtrace.io/tx/"
            ;;
        31)
            net_name="Rootstock Testnet"
            currency="RBTC"
            url_address="https://explorer.testnet.rootstock.io/address/"
            url_tx="https://explorer.testnet.rootstock.io/tx/"
            ;;
        51)
            net_name="XDC Apothem Network"
            currency="TXDC"
            url_address="https://explorer.apothem.network/address/"
            url_tx="https://explorer.apothem.network/tx/"
            ;;

        # MAINNET
        1)
            net_name="Ethereum"
            url_address="https://etherscan.io/address/"
            url_tx="https://etherscan.io/tx/"
            ;;
        42161)
            net_name="Arbitrum One"
            url_address="https://arbiscan.io/address/"
            url_tx="https://arbiscan.io/tx/"
            ;;
        42170)
            net_name="Arbitrum Nova"
            url_address="https://nova.arbiscan.io/address/"
            url_tx="https://nova.arbiscan.io/tx/"
            ;;
        8453)
            net_name="Base"
            url_address="https://basescan.org/address/"
            url_tx="https://basescan.org/tx/"
            ;;
        56)
            net_name="BNB Smart Chain"
            currency="BNB"
            url_address="https://bscscan.com/address/"
            url_tx="https://bscscan.com/tx/"
            ;;
        137)
            net_name="Polygon"
            currency="POL"
            url_address="https://polygonscan.com/address/"
            url_tx="https://polygonscan.com/tx/"
            ;;
        43114)
            net_name="Avalanche"
            currency="AVAX"
            url_address="https://avascan.info/blockchain/c/address/"
            url_tx="https://avascan.info/blockchain/c/tx/"
            ;;
        30)
            net_name="Rootstock"
            currency="RBTC"
            url_address="https://explorer.rootstock.io/address/"
            url_tx="https://explorer.rootstock.io/tx/"
            ;;
        50)
            net_name="XDC Network"
            currency="XDC"
            url_address="https://xdc.network/address/"
            url_tx="https://xdc.network/txs/"
            ;;
        *)
            net_name="Network name not defined :("
            currency=""
            url_address=""
            url_tx=""
    esac
    echo "$net_name|$currency|$url_address|$url_tx"
}

_loading() {
    local duration=0.5 bar_length=24
    for ((i = 0; i <= bar_length; i++)); do
        local progress=$(for ((j = 0; j < i; j++)); do printf "\033[44m \033[0m "; done)
        local empty=$(for ((j = i; j < bar_length; j++)); do printf "  "; done)
        printf "\r%s%s" "$progress" "$empty"
        sleep $(bc <<< "$duration / $bar_length")
    done
    echo
}


############
### IPFS ###
############

up_file(){ # UPLOAD A BINARY FILE TO IPFS

    local filename filePath step=1

    echo "Please enter the following parameters to upload the file to IPFS:"
    echo -e "filename filePath\n"

    while true; do
        case $step in
            1)
                _check_input "Filename: " filename -1 "true" 'true' "Filename is required." ""
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "File Path: " filePath 1 "true" 'true' "File Path is required." ""
                _step_back && continue
                [ -f "$filePath" ] || { echo "Error: File doesn't exist at the specified path."; continue; }
                step=3
                ;;
            3)
                echo -e "\nYou've entered the following parameters:"
                echo "Filename: $filename"
                echo -e "File Path: $filePath\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local response=$(curl --silent --location --request POST \
        'https://ipfsapi-v2.vottun.tech/ipfs/v2/file/upload' "${auth[@]}" \
        --header 'Content-Type: multipart/form-data' \
        --form 'filename="'"$filename"'"' \
        --form 'file=@"'"$filePath"'"')

    _loading
    echo -e "\nServer response:\n$response"
}

up_folder(){ # UPLOAD A FOLDER OR ZIP WITH MULTIPLE FILES TO IPFS

    local filePath

    echo -e "Please enter the file path to upload the folder or zip to IPFS:\n"

    while true; do 
        _check_input "File Path: " filePath -1 "true" 'true' "File Path is required." ""
        [[ $? -eq 99 ]] && continue

        if [ -d "$filePath" ]; then
            tempZip="${filePath%/}.zip"
            echo "Zipping into $tempZip..."
            zip -r "$tempZip" "$filePath" || { echo "Error: Failed to create zip file."; return 1; }
            filePath="$tempZip"
        elif [ ! -f "$filePath" ]; then
            echo "Error: File or directory doesn't exist."; continue
        fi
                
        echo -e "\nYou've entered the following parameter:\nFile Path: $filePath\n"

        _confirmation && break || [[ $? -eq 99 ]] || return 1
    done

    local response=$(curl --silent --location --request POST \
        'https://ipfsapi-v2.vottun.tech/ipfs/v2/upload/zip' "${auth[@]}" \
        --header 'Content-Type: multipart/form-data' \
        --form 'file=@"'"$filePath"'"')

    _loading
    echo -e "\nServer response:\n$response"
    [[ -n "$tempZip" && -f "$tempZip" ]] && rm -f "$tempZip"
}

up_metadata(){ # UPLOAD A JSON FILE TO IPFS

    local name image description edition attributes=() data_names=() data_values=() step=1

    echo "Please enter the following parameters to upload the metadata to IPFS:"
    echo -e "name image description (edition) (attributes) (data)\n"

    while true; do
        case $step in
            1)
                _check_input "Name: " name -1 "true" 'true' "Name is required." ""
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Image: " image 1 "true" '[[ ${#input} -ge 46 ]]' \
                    "Image is required." "Image URL must be longer."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Description: " description 2 "true" 'true' "Description is required." ""
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Edition (optional): " edition 3 "false" 'true' "" ""
                _step_back && continue
                step=5
                ;;
            5)
                attributes=()
                local attr_count=1              
                while true; do
                    read -e -p "Add attributes? (Y/N): " add_attributes
                    [[ "$add_attributes" =~ ^(<<|\.\.|!undo|!back|!del)$ ]] && step=4 && break
                    [[ -z "$add_attributes" ]] && step=6 && break
                    [[ "$add_attributes" =~ ^[Yy]$ ]] && {
                        while true; do
                            read -e -p "Trait type for attribute $attr_count: " trait_type
                            [[ -z "$trait_type" ]] && echo "Trait type is required!" && continue
                            [[ "$trait_type" =~ ^(<<|\.\.|!undo|!back|!del)$ ]] && {
                                (( attr_count > 1 )) && attributes=("${attributes[@]:0:${#attributes[@]}-1}") && ((attr_count--)) && continue
                                break
                            }                          
                            while true; do
                                read -e -p "Value for trait '$trait_type': " value
                                [[ -z "$value" ]] && echo "Value is required for the trait!" && continue
                                [[ "$value" =~ ^(<<|\.\.|!undo|!back|!del)$ ]] && {
                                    (( attr_count > 1 )) && attributes=("${attributes[@]:0:${#attributes[@]}-1}") && ((attr_count--)) && continue 2
                                }                               
                                [[ "$value" =~ ^[0-9]+$ ]] && attributes+=("{\"trait_type\": \"$trait_type\", \"value\": $value}") || attributes+=("{\"trait_type\": \"$trait_type\", \"value\": \"$value\"}")
                                ((attr_count++))
                                break
                            done                           
                            while true; do
                                read -e -p "Add another attribute? (Y/N): " add_more
                                [[ "$add_more" =~ ^(<<|\.\.|!undo|!back|!del)$ ]] && {
                                    (( attr_count > 1 )) && attributes=("${attributes[@]:0:${#attributes[@]}-1}") && ((attr_count--)) && continue 2
                                    break 2
                                }
                                [[ -z "$add_more" || "$add_more" =~ ^[Nn]$ ]] && step=6 && break 3
                                [[ "$add_more" =~ ^[Yy]$ ]] && break
                                echo "Invalid input. Please enter 'Y' or 'N'."
                            done
                        done
                    }
                    [[ "$add_attributes" =~ ^[Nn]$ ]] && step=6 && break
                    echo "Invalid input. Please enter 'Y' or 'N'."
                done
                ;;
            6)
                data_names=() data_values=()
                local data_count=1
                while true; do
                    read -e -p "Add custom data? (Y/N): " add_data
                    [[ "$add_data" =~ ^(<<|\.\.|!undo|!back|!del)$ ]] && step=5 && break
                    [[ -z "$add_data" ]] && step=7 && break
                    [[ "$add_data" =~ ^[Yy]$ ]] && {
                        while true; do
                            read -e -p "Data name $data_count: " dataName
                            [[ -z "$dataName" ]] && echo "Data name is required!" && continue
                            [[ "$dataName" =~ ^(<<|\.\.|!undo|!back|!del)$ ]] && {
                                (( data_count > 1 )) && {
                                    data_names=("${data_names[@]:0:${#data_names[@]}-1}")
                                    data_values=("${data_values[@]:0:${#data_values[@]}-1}")
                                    ((data_count--))
                                    continue
                                }
                                break
                            }
                            while true; do
                                read -e -p "Value for '$dataName': " value
                                [[ -z "$value" ]] && echo "Value is required for the data name!" && continue
                                [[ "$value" =~ ^(<<|\.\.|!undo|!back|!del)$ ]] && {
                                    (( data_count > 1 )) && {
                                        data_names=("${data_names[@]:0:${#data_names[@]}-1}")
                                        data_values=("${data_values[@]:0:${#data_values[@]}-1}")
                                        ((data_count--))
                                    }
                                    continue 2
                                }
                                data_names+=("$dataName")
                                data_values+=("$value")
                                ((data_count++))
                                break
                            done
                            while true; do
                                read -e -p "Add another custom data field? (Y/N): " add_more
                                [[ "$add_more" =~ ^(<<|\.\.|!undo|!back|!del)$ ]] && {
                                    (( data_count > 1 )) && {
                                        data_names=("${data_names[@]:0:${#data_names[@]}-1}")
                                        data_values=("${data_values[@]:0:${#data_values[@]}-1}")
                                        ((data_count--))
                                        continue 2
                                    }
                                    echo && break 2
                                }
                                [[ -z "$add_more" || "$add_more" =~ ^[Nn]$ ]] && step=7 && break 3
                                [[ "$add_more" =~ ^[Yy]$ ]] && break
                                echo "Invalid input. Please enter 'Y' or 'N'."
                            done
                        done
                    }
                    [[ "$add_data" =~ ^[Nn]$ ]] && step=7 && break
                    echo "Invalid input. Please enter 'Y' or 'N'."
                done
                ;;
            7)
                echo -e "\nYou've entered the following parameters:"
                echo "Name: $name"
                echo "Image: $image"
                echo "Description: $description"
                [ -n "$edition" ] && echo "Edition: $edition"
                [[ ${#attributes[@]} -gt 0 ]] && echo "Attributes: ${attributes[*]}"
                if [[ ${#data_names[@]} -gt 0 ]]; then
                    local data_display="{"
                    for ((i=0; i<${#data_names[@]}; i++)); do
                        if [[ "${data_values[i]}" =~ ^[0-9]+$ ]]; then
                            data_display+="\"${data_names[i]}\": ${data_values[i]}"
                        else
                            data_display+="\"${data_names[i]}\": \"${data_values[i]}\""
                        fi
                        [[ $i -lt $(( ${#data_names[@]} - 1 )) ]] && data_display+=", "
                    done
                    data_display+="}"
                    echo "Data: $data_display"
                fi
                echo
                
                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local attributes_json=$(printf '%s\n' "${attributes[@]}" | jq -s '.')
    local data_json=$(jq -n '{data: {}}')
    for ((i=0; i<${#data_names[@]}; i++)); do
        if [[ "${data_values[i]}" =~ ^[0-9]+$ ]]; then
            data_json=$(echo "$data_json" | jq --arg key "${data_names[i]}" --argjson val "${data_values[i]}" '.data[$key] = $val')
        else
            data_json=$(echo "$data_json" | jq --arg key "${data_names[i]}" --arg val "${data_values[i]}" '.data[$key] = $val')
        fi
    done

    local data=$(jq -n \
        --arg name "$name" \
        --arg image "$image" \
        --arg description "$description" \
        --arg edition "$edition" \
        --argjson attributes "$attributes_json" \
        --argjson data "$data_json" \
        '{
            name: $name,
            image: $image,
            description: $description
        } + 
        (if $edition != "" then {edition: $edition} else {} end) +
        (if $attributes != [] then {attributes: $attributes} else {} end) +
        $data')

    local response=$(curl --silent --location --request POST 'https://ipfsapi-v2.vottun.tech/ipfs/v2/file/metadata' \
        "${auth[@]}" $ct_json --data-raw "$data")

    _loading
    echo -e "\nServer response:\n$response"
}


##############
### ERC-20 ###
##############

deploy20() { # DEPLOY AN ERC-20 SMART CONTRACT

    local name symbol alias initialSupply network gasLimit step=1

    echo "Please enter the following parameters to deploy the ERC-20 contract:"
    echo -e "name symbol alias initialSupply network (gasLimit)\n"

    while true; do
        case $step in
            1)
                _check_input "Name: " name -1 "true" 'true' "Name is required." ""
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Symbol: " symbol 1 "true" 'true' "Symbol is required." ""
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Alias: " alias 2 "true" 'true' "Alias is required." ""
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Initial Supply: " initialSupply 3 "true" '[[ "$input" =~ ^[0-9]*\.?[0-9]+$ ]]' \
                    "Initial Supply is required." "Initial Supply must be a valid integer or decimal."
                _step_back && continue
                initialSupply_wei=$(echo "$initialSupply * 10^18 / 1" | bc)
                step=5
                ;;
            5)
                _check_input "Network: " network 4 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=6
                ;;
            6)
                _check_input "Gas Limit (optional): " gasLimit 5 "false" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "" "Gas Limit must be an integer number if provided."
                _step_back && continue
                step=7
                ;;
            7)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Name: $name"
                echo "Symbol: $symbol"
                echo "Alias: $alias"
                echo "Initial Supply: $initialSupply"
                echo "Network: $net_name"
                [ -n "$gasLimit" ] && echo "Gas Limit: $gasLimit"
                echo

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg name "$name" \
        --arg symbol "$symbol" \
        --arg alias "$alias" \
        --argjson network "$network" \
        --arg gasLimit "$gasLimit" \
        '{
            name: $name,
            symbol: $symbol,
            alias: $alias,
            network: $network
        } + 
        (if $gasLimit != "" then {gasLimit: ($gasLimit | tonumber)} else {} end)')  
    data=$(echo "$data" | sed "s/^{/{\"initialSupply\":$initialSupply_wei, /")

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/erc/v1/erc20/deploy' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')

    if [[ -n "$txHash" ]]; then
        contractAddress=$(echo "$response" | jq -r '.contractAddress // empty')
        echo -e "\nDeploying the ERC-20 contract on $net_name..."
        _loading
        [[ -n "$url_tx" ]] && echo -e "\nBlock explorer URLs:\n$url_address$contractAddress\n$url_tx$txHash"
    fi
}

transfer20(){ # TRANSFER TOKENS TO AN ADDRESS

    local contractAddress recipient network amount gasLimit step=1

    echo "Please enter the following parameters to make the token transfers:"
    echo -e "contractAddress recipient network amount (gasLimit)\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Recipient: " recipient 1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Recipient is required." "Recipient must start with '0x' and be 42 characters long."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Network: " network 2 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Amount: " amount 3 "true" '[[ "$input" =~ ^[0-9]*\.?[0-9]+$ ]]' \
                    "Amount is required." "Amount must be a valid integer or decimal."
                _step_back && continue
                amount_wei=$(echo "$amount * 10^18 / 1" | bc)
                step=5
                ;;
            5)
                _check_input "Gas Limit (optional): " gasLimit 4 "false" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "" "Gas Limit must be an integer number if provided."
                _step_back && continue
                step=6
                ;;
            6)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Recipient: $recipient"
                echo "Network: $net_name"
                echo "Amount: $amount"
                [ -n "$gasLimit" ] && echo "Gas Limit: $gasLimit"
                echo

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --arg recipient "$recipient" \
        --argjson network "$network" \
        --arg gasLimit "$gasLimit" \
        '{
            contractAddress: $contractAddress,
            recipient: $recipient,
            network: $network
        } + 
        (if $gasLimit != "" then {gasLimit: $gasLimit | tonumber} else {} end)')
    data=$(echo "$data" | sed "s/^{/{\"amount\":$amount_wei, /")

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/erc/v1/erc20/transfer' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')

    if [[ -n "$txHash" ]]; then
        local symbol_query=$(curl --silent --location --request GET 'https://api.vottun.tech/erc/v1/erc20/symbol' \
            "${auth[@]}" $ct_json \
            --data-raw '{
                "contractAddress": "'"$contractAddress"'",
                "network": '$network'
            }')

        symbol=$(echo "$symbol_query" | jq -r '.symbol // empty')
        echo -e "\nSending: $amount $symbol\nto: $recipient"
        _loading
        [[ -n "$url_tx" ]] && echo -e "\nBlock explorer URL:\n$url_tx$txHash"
    fi
}

transfer_from(){ # TRANSFER TOKENS FROM A SENDER'S ACCOUNT TO A RECEIVER'S ADDRESS

    local contractAddress sender recipient network amount gasLimit step=1

    echo "Please enter the following parameters to make the token transfers:"
    echo -e "contractAddress sender recipient network amount (gasLimit)\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Sender: " sender 1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Sender is required." "Sender must start with '0x' and be 42 characters long."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Recipient: " recipient 2 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Recipient is required." "Recipient must start with '0x' and be 42 characters long."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Network: " network 3 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=5
                ;;
            5)
                _check_input "Amount: " amount 4 "true" '[[ "$input" =~ ^[0-9]*\.?[0-9]+$ ]]' \
                    "Amount is required." "Amount must be a valid integer or decimal."
                _step_back && continue
                amount_wei=$(echo "$amount * 10^18 / 1" | bc)
                step=6
                ;;
            6)
                _check_input "Gas Limit (optional): " gasLimit 5 "false" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "" "Gas Limit must be an integer number if provided."
                _step_back && continue
                step=7
                ;;
            7)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Sender: $sender"
                echo "Recipient: $recipient"
                echo "Network: $net_name"
                echo "Amount: $amount"
                [ -n "$gasLimit" ] && echo "Gas Limit: $gasLimit"
                echo

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --arg recipient "$recipient" \
        --arg sender "$sender" \
        --argjson network "$network" \
        --arg gasLimit "$gasLimit" \
        '{
            contractAddress: $contractAddress,
            recipient: $recipient,
            sender: $sender,
            network: $network
        } + 
        (if $gasLimit != "" then {gasLimit: $gasLimit | tonumber} else {} end)')
    data=$(echo "$data" | sed "s/^{/{\"amount\":$amount_wei, /")

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/erc/v1/erc20/transferFrom' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')

    if [[ -n "$txHash" ]]; then
        local symbol_query=$(curl --silent --location --request GET 'https://api.vottun.tech/erc/v1/erc20/symbol' \
            "${auth[@]}" $ct_json \
            --data-raw '{
                "contractAddress": "'"$contractAddress"'",
                "network": '$network'
            }')

        symbol=$(echo "$symbol_query" | jq -r '.symbol // empty')
        echo -e "\nSending: $amount $symbol\nfrom: $sender\nto: $recipient"
        _loading
        [[ -n "$url_tx" ]] && echo -e "\nBlock explorer URL:\n$url_tx$txHash"
    fi
}

incr_allowance() { # GRANT A SPENDER ACCOUNT THE RIGHT TO MANAGE A SPECIFIED AMOUNT OF TOKENS

    local contractAddress spender network addedValue gasLimit step=1

    echo "Please enter the following parameters to grant the right to manage an amount of tokens:"
    echo -e "contractAddress spender network addedValue (gasLimit)\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Spender: " spender 1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Spender is required." "Spender must start with '0x' and be 42 characters long."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Network: " network 2 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Added Value: " addedValue 3 "true" '[[ "$input" =~ ^[0-9]*\.?[0-9]+$ ]]' \
                    "Added Value is required." "Added Value must be a valid integer or decimal."
                _step_back && continue
                addedValue_wei=$(echo "$addedValue * 10^18 / 1" | bc)
                step=5
                ;;
            5)
                _check_input "Gas Limit (optional): " gasLimit 4 "false" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "" "Gas Limit must be an integer number if provided."
                _step_back && continue
                step=6
                ;;
            6)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Spender: $spender"
                echo "Network: $net_name"
                echo "Added Value: $addedValue"
                [ -n "$gasLimit" ] && echo "Gas Limit: $gasLimit"
                echo

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data
    data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --arg spender "$spender" \
        --argjson network "$network" \
        --arg gasLimit "$gasLimit" \
        '{
            contractAddress: $contractAddress,
            spender: $spender,
            network: $network
        } + 
        (if $gasLimit != "" then {gasLimit: $gasLimit | tonumber} else {} end)')
    data=$(echo "$data" | sed "s/^{/{\"addedValue\":$addedValue_wei, /")

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/erc/v1/erc20/increaseAllowance' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')

    if [[ -n "$txHash" ]]; then
        local symbol_query=$(curl --silent --location --request GET 'https://api.vottun.tech/erc/v1/erc20/symbol' \
            "${auth[@]}" $ct_json \
            --data-raw '{
                "contractAddress": "'"$contractAddress"'",
                "network": '$network'
            }')

        symbol=$(echo "$symbol_query" | jq -r '.symbol // empty')
        echo -e "\nIncreasing allowance to: $addedValue $symbol\nfor: $spender"
        _loading
        [[ -n "$url_tx" ]] && echo -e "\nBlock explorer URL:\n$url_tx$txHash"
    fi
}

decr_allowance(){ # REVOKE A SPENDER ACCOUNT THE RIGHT TO MANAGE A SPECIFIED AMOUNT OF TOKENS

    local contractAddress spender network substractedValue gasLimit step=1

    echo "Please enter the following parameters to revoke the right to manage an amount of tokens:"
    echo -e "contractAddress spender network substractedValue (gasLimit)\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Spender: " spender 1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Spender is required." "Spender must start with '0x' and be 42 characters long."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Network: " network 2 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Substracted Value: " substractedValue 3 "true" '[[ "$input" =~ ^[0-9]*\.?[0-9]+$ ]]' \
                    "Substracted Value is required." "Substracted Value must be a valid integer or decimal."
                _step_back && continue
                substractedValue_wei=$(echo "$substractedValue * 10^18 / 1" | bc)
                step=5
                ;;
            5)
                _check_input "Gas Limit (optional): " gasLimit 4 "false" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "" "Gas Limit must be an integer number if provided."
                _step_back && continue
                step=6
                ;;
            6)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Spender: $spender"
                echo "Network: $net_name"
                echo "Substracted Value: $substractedValue"
                [ -n "$gasLimit" ] && echo "Gas Limit: $gasLimit"
                echo

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --arg spender "$spender" \
        --argjson network "$network" \
        --arg gasLimit "$gasLimit" \
        '{
            contractAddress: $contractAddress,
            spender: $spender,
            network: $network
        } + 
        (if $gasLimit != "" then {gasLimit: $gasLimit | tonumber} else {} end)')
    data=$(echo "$data" | sed "s/^{/{\"substractedValue\":$substractedValue_wei, /")

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/erc/v1/erc20/decreaseAllowance' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')

    if [[ -n "$txHash" ]]; then
        local symbol_query=$(curl --silent --location --request GET 'https://api.vottun.tech/erc/v1/erc20/symbol' \
            "${auth[@]}" $ct_json \
            --data-raw '{
                "contractAddress": "'"$contractAddress"'",
                "network": '$network'
            }')

        symbol=$(echo "$symbol_query" | jq -r '.symbol // empty')
        echo -e "\nDecreasing allowance to: $substractedValue $symbol\nfor: $spender"
        _loading
        [[ -n "$url_tx" ]] && echo -e "\nBlock explorer URL:\n$url_tx$txHash"
    fi
}

allowance(){ # DISPLAY THE TOTAL AMOUNT OF TOKENS THE OWNER HAS AUTHORIZED THE SPENDER TO TRANSACT

    local contractAddress network owner spender step=1

    echo "Please enter the following parameters to display the amount of tokens authorized for the spender to transact:"
    echo -e "contractAddress network owner spender\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Owner: " owner 2 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Owner is required." "Owner must start with '0x' and be 42 characters long."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Spender: " spender 3 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Spender is required." "Spender must start with '0x' and be 42 characters long."
                _step_back && continue
                step=5
                ;;
            5)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Network: $net_name"
                echo "Owner: $owner"
                echo -e "Spender: $spender\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        --arg owner "$owner" \
        --arg spender "$spender" \
        '{
            contractAddress: $contractAddress,
            network: $network,
            owner: $owner,
            spender: $spender
        }')

    local response=$(curl --silent --location --request GET 'https://api.vottun.tech/erc/v1/erc20/allowance' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
}

name(){ # DISPLAY THE NAME OF A SMART CONTRACT

    local contractAddress network step=1

    echo "Please enter the following parameters to display the name of the smart contract:"
    echo -e "contractAddress network\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo -e "Network: $net_name\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        '{
            contractAddress: $contractAddress,
            network: $network
        }')

    local response=$(curl --silent --location --request GET 'https://api.vottun.tech/erc/v1/erc20/name' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
}

symbol(){ # DISPLAY THE SYMBOL OF A SMART CONTRACT

    local contractAddress network step=1

    echo "Please enter the following parameters to display the symbol of the smart contract:"
    echo -e "contractAddress network\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo -e "Network: $net_name\n"
                
                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        '{
            contractAddress: $contractAddress,
            network: $network
        }')

    local response=$(curl --silent --location --request GET 'https://api.vottun.tech/erc/v1/erc20/symbol' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
}

supply(){ # DISPLAY THE TOTAL SUPPLY OF TOKENS CREATED IN AN ERC-20 SMART CONTRACT

    local contractAddress network step=1

    echo "Please enter the following parameters to display the total supply of tokens created in the smart contract:"
    echo -e "contractAddress network\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo -e "Network: $net_name\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        '{
            contractAddress: $contractAddress,
            network: $network
        }')

    local response=$(curl --silent --location --request GET 'https://api.vottun.tech/erc/v1/erc20/totalSupply' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
}

decimals(){ # DISPLAY THE DECIMALS USED FOR TOKENS IN AN ERC-20 SMART CONTRACT

    local contractAddress network step=1

    echo "Please enter the following parameters to display the decimals used for tokens in the smart contract:"
    echo -e "contractAddress network\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo -e "Network: $net_name\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done 

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        '{
            contractAddress: $contractAddress,
            network: $network
        }')

    local response=$(curl --silent --location --request GET 'https://api.vottun.tech/erc/v1/erc20/decimals' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
}

balance20(){ # DISPLAY THE BALANCE OF TOKENS HELD BY AN ADDRESS

    local contractAddress network address step=1

    echo "Please enter the following parameters to display the balance of tokens held by the address:"
    echo -e "contractAddress network address\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Address: " address 2 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Address is required." "Address must start with '0x' and be 42 characters long."
                _step_back && continue
                step=4
                ;;
            4)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Network: $net_name"
                echo -e "Address: $address\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        --arg address "$address" \
        '{
            contractAddress: $contractAddress,
            network: $network,
            address: $address
        }')

    local response=$(curl --silent --location --request GET 'https://api.vottun.tech/erc/v1/erc20/balanceOf' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
}


###############
### ERC-721 ###
###############

deploy721() { # DEPLOY AN ERC-721 SMART CONTRACT

    local name symbol network alias gasLimit step=1

    echo "Please enter the following parameters to deploy the ERC-721 contract:"
    echo -e "name symbol network (alias) (gasLimit)\n"

    while true; do
        case $step in
            1)
                _check_input "Name: " name -1 "true" 'true' "Name is required." ""
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Symbol: " symbol 1 "true" 'true' "Symbol is required." ""
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Network: " network 2 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Alias (optional): " alias 3 "false" 'true' "" ""
                _step_back && continue
                step=5
                ;;
            5)
                _check_input "Gas Limit (optional): " gasLimit 4 "false" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "" "Gas Limit must be an integer number if provided."
                _step_back && continue
                step=6
                ;;
            6)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Name: $name"
                echo "Symbol: $symbol"
                echo "Network: $net_name"
                [ -n "$alias" ] && echo "Alias: $alias"
                [ -n "$gasLimit" ] && echo "Gas Limit: $gasLimit"
                echo

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg name "$name" \
        --arg symbol "$symbol" \
        --argjson network "$network" \
        --arg alias "$alias" \
        --arg gasLimit "$gasLimit" \
        '{
            name: $name,
            symbol: $symbol,
            network: $network
        } + 
        (if $alias != "" then {alias: $alias} else {} end) + 
        (if $gasLimit != "" then {gasLimit: $gasLimit | tonumber} else {} end)')

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/erc/v1/erc721/deploy' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')

    if [[ -n "$txHash" ]]; then
        contractAddress=$(echo "$response" | jq -r '.contractAddress // empty')
        echo -e "\nDeploying the ERC-721 contract on $net_name..."
        _loading
        [[ -n "$url_tx" ]] && echo -e "\nBlock explorer URLs:\n$url_address$contractAddress\n$url_tx$txHash"
    fi
}

mint721(){ # MINT AN NFT WITH THE PROVIDED METADATA TO THE SPECIFIED ADDRESS

    local recipientAddress tokenId ipfsUri ipfsHash network contractAddress royaltyPercentage gasLimit step=1

    echo "Please enter the following parameters to mint the NFT:"
    echo -e "recipientAddress tokenId ipfsUri ipfsHash network contractAddress (royaltyPercentage) (gasLimit)\n"

    while true; do
        case $step in
            1)
                _check_input "Recipient Address: " recipientAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Recipient Address is required." "Recipient Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Token ID: " tokenId 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Token ID is required." "Token ID must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "IPFS URI: " ipfsUri 2 "true" '[[ ${#input} -ge 46 ]]' \
                    "IPFS URI is required." "The IPFS URI must be longer."
                _step_back && continue

                ipfsHash="${ipfsUri##*/}"
                echo "IPFS Hash (autofilled): $ipfsHash"        
                step=4
                ;;
            4)
                _check_input "Network: " network 3 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=5
                ;;
            5)
                _check_input "Contract Address: " contractAddress 4 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                _step_back && continue
                step=6
                ;;
            6)
                _check_input "Royalty Percentage (optional): " royaltyPercentage 5 "false" \
                    '[[ "$input" =~ ^[0-9]+$ ]]' "" "Royalty Percentage must be an integer number if provided."
                _step_back && continue
                step=7
                ;;
            7)
                _check_input "Gas Limit (optional): " gasLimit 6 "false" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "" "Gas Limit must be an integer number if provided."
                _step_back && continue
                step=8
                ;;
            8)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Recipient Address: $recipientAddress"
                echo "Token ID: $tokenId"
                echo "IPFS URI: $ipfsUri"
                echo "IPFS Hash: $ipfsHash"
                echo "Network: $net_name"
                echo "Contract Address: $contractAddress"
                [ -n "$royaltyPercentage" ] && echo "Royalty Percentage: $royaltyPercentage"
                [ -n "$gasLimit" ] && echo "Gas Limit: $gasLimit"
                echo

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg recipientAddress "$recipientAddress" \
        --argjson tokenId "$tokenId" \
        --arg ipfsUri "$ipfsUri" \
        --arg ipfsHash "$ipfsHash" \
        --argjson network "$network" \
        --arg contractAddress "$contractAddress" \
        --arg royaltyPercentage "$royaltyPercentage" \
        --arg gasLimit "$gasLimit" \
        '{
            recipientAddress: $recipientAddress,
            tokenId: $tokenId,
            ipfsUri: $ipfsUri,
            ipfsHash: $ipfsHash,
            network: $network,
            contractAddress: $contractAddress
        } + 
        (if $royaltyPercentage != "" then {royaltyPercentage: $royaltyPercentage | tonumber} else {} end) + 
        (if $gasLimit != "" then {gasLimit: $gasLimit | tonumber} else {} end)')

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/erc/v1/erc721/mint' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')

    if [[ -n "$txHash" ]]; then
        echo -e "\nMinting NFT with Token ID $tokenId\nto: $recipientAddress"
        _loading
        [[ -n "$url_tx" ]] && echo -e "\nBlock explorer URL:\n$url_tx$txHash"
    fi
}

transfer721(){ # TRANSFER AN NFT TO AN ADDRESS

    local contractAddress network id from to step=1

    echo "Please enter the following parameters to transfer the NFT:"
    echo -e "contractAddress network id from to\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Token ID: " id 2 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Token ID is required." "Token ID must be an integer number."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "From: " from 3 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "From is required." "From must start with '0x' and be 42 characters long."
                _step_back && continue
                step=5
                ;;
            5)
                _check_input "To: " to 4 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "To is required." "To must start with '0x' and be 42 characters long."
                _step_back && continue
                step=6
                ;;
            6)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Network: $net_name"
                echo "Token ID: $id"
                echo "From: $from"
                echo -e "To: $to\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        --argjson id "$id" \
        --arg from "$from" \
        --arg to "$to" \
        '{
            contractAddress: $contractAddress,
            network: $network,
            id: $id,
            from: $from,
            to: $to
        }')

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/erc/v1/erc721/transfer' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')

    if [[ -n "$txHash" ]]; then
        echo -e "\nSending NFT with Token ID $id\nfrom: $from\nto: $to"
        _loading
        [[ -n "$url_tx" ]] && echo -e "\nBlock explorer URL:\n$url_tx$txHash"
    fi
}

balance721(){ # DISPLAY THE NFT BALANCE OF AN ADDRESS IN THE SPECIFIED SMART CONTRACT AND NETWORK

    local contractAddress network address step=1

    echo "Please enter the following parameters to display the balance of NFTs held by the address:"
    echo -e "contractAddress network address\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Address: " address 2 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Address is required." "Address must start with '0x' and be 42 characters long."
                _step_back && continue
                step=4
                ;;
            4)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Network: $net_name"
                echo -e "Address: $address\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        --arg address "$address" \
        '{
            contractAddress: $contractAddress,
            network: $network,
            address: $address
        }')

    local response=$(curl --silent --location --request GET 'https://api.vottun.tech/erc/v1/erc721/balanceOf' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
}

uri721(){ # DISPLAY THE METADATA URI FOR AN NFT IN THE SPECIFIED CONTRACT

    local contractAddress network id step=1

    echo "Please enter the following parameters to display the metadata URI for the NFT:"
    echo -e "contractAddress network id\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Token ID: " id 2 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Token ID is required." "Token ID must be an integer number."
                _step_back && continue
                step=4
                ;;
            4)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Network: $net_name"
                echo -e "Token ID: $id\n"
                
                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        --argjson id "$id" \
        '{
            contractAddress: $contractAddress,
            network: $network,
            id: $id
        }')

    local response=$(curl --silent --location --request GET 'https://api.vottun.tech/erc/v1/erc721/tokenUri' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
}

owner(){ # DISPLAY THE ADDRESS OF THE OWNER OF AN NFT

    local contractAddress network id step=1

    echo "Please enter the following parameters to display the address of the owner of the NFT:"
    echo -e "contractAddress network id\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Token ID: " id 2 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Token ID is required." "Token ID must be an integer number."
                _step_back && continue
                step=4
                ;;
            4)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Network: $net_name"
                echo -e "Token ID: $id\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        --argjson id "$id" \
        '{
            contractAddress: $contractAddress,
            network: $network,
            id: $id
        }')

    local response=$(curl --silent --location --request GET 'https://api.vottun.tech/erc/v1/erc721/ownerOf' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
}


################
### ERC-1155 ###
################

deploy1155(){ # DEPLOY AN ERC-1155 SMART CONTRACT

    local name symbol ipfsUri royaltyRecipient royaltyValue network alias gasLimit step=1

    echo "Please enter the following parameters to deploy the ERC-1155 contract:"
    echo -e "name symbol ipfsUri royaltyRecipient royaltyValue network alias (gasLimit)\n"

    while true; do
        case $step in
            1)
                _check_input "Name: " name -1 "true" 'true' "Name is required." ""
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Symbol: " symbol 1 "true" 'true' "Symbol is required." ""
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "IPFS URI: " ipfsUri 2 "true" '[[ ${#input} -ge 46 ]]' \
                    "IPFS URI is required." "The IPFS URI must be longer."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Royalty Recipient: " royaltyRecipient 3 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Royalty Recipient is required." "Royalty Recipient must start with '0x' and be 42 characters long."
                _step_back && continue
                step=5
                ;;
            5)
                _check_input "Royalty Value: " royaltyValue 4 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Royalty Value is required." "Royalty Value must be an integer number."
                _step_back && continue
                step=6
                ;;
            6)
                _check_input "Network: " network 5 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=7
                ;;
            7)
                _check_input "Alias: " alias 6 "true" 'true' "Alias is required." ""
                _step_back && continue
                step=8
                ;;
            8)
                _check_input "Gas Limit (optional): " gasLimit 7 "false" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "" "Gas Limit must be an integer number if provided."
                _step_back && continue
                step=9
                ;;
            9)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Name: $name"
                echo "Symbol: $symbol"
                echo "IPFS URI: $ipfsUri"
                echo "Royalty Recipient: $royaltyRecipient"
                echo "Royalty Value: $royaltyValue"
                echo "Network: $net_name"
                echo "Alias: $alias"
                [ -n "$gasLimit" ] && echo "Gas Limit: $gasLimit"
                echo

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg name "$name" \
        --arg symbol "$symbol" \
        --arg ipfsUri "$ipfsUri" \
        --arg royaltyRecipient "$royaltyRecipient" \
        --argjson royaltyValue "$royaltyValue" \
        --argjson network "$network" \
        --arg alias "$alias" \
        --arg gasLimit "$gasLimit" \
        '{
            name: $name,
            symbol: $symbol,
            ipfsUri: $ipfsUri,
            royaltyRecipient: $royaltyRecipient,
            royaltyValue: $royaltyValue,
            network: $network,
            alias: $alias
        } + 
        (if $gasLimit != "" then {gasLimit: $gasLimit | tonumber} else {} end)')

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/erc/v1/erc1155/deploy' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')

    if [[ -n "$txHash" ]]; then
        contractAddress=$(echo "$response" | jq -r '.contractAddress // empty')
        echo -e "\nDeploying the ERC-1155 contract on $net_name..."
        _loading
        [[ -n "$url_tx" ]] && echo -e "\nBlock explorer URLs:\n$url_address$contractAddress\n$url_tx$txHash"
    fi
}

mint1155(){ # MINT THE SPECIFIED AMOUNT OF COPIES OF AN NFT WITH THE PROVIDED METADATA TO THE GIVEN ADDRESS

    local contractAddress network to id amount step=1

    echo "Please enter the following parameters to mint a number of copies of an NFT to the address:"
    echo -e "contractAddress network to id amount\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "To: " to 2 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "To is required." "To must start with '0x' and be 42 characters long."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Token ID: " id 3 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Token ID is required." "Token ID must be an integer number."
                _step_back && continue
                step=5
                ;;
            5)
                _check_input "Amount: " amount 4 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Amount is required." "Amount must be an integer number."
                _step_back && continue
                step=6
                ;;
            6)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Network: $net_name"
                echo "To: $to"
                echo "Token ID: $id"
                echo -e "Amount: $amount\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        --arg to "$to" \
        --argjson id "$id" \
        --argjson amount "$amount" \
        '{
            contractAddress: $contractAddress,
            network: $network,
            to: $to,
            id: $id,
            amount: $amount
        }')

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/erc/v1/erc1155/mint' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')

    if [[ -n "$txHash" ]]; then
        echo -e "\nMinting $amount NFTs with Token ID $id\nto: $to"
        _loading
        [[ -n "$url_tx" ]] && echo -e "\nBlock explorer URL:\n$url_tx$txHash"
    fi
}

mint_batch(){ # MINT THE SPECIFIED AMOUNT OF COPIES OF MULTIPLE NFTS WITH THE PROVIDED METADATA TO THE GIVEN ADDRESS

    local contractAddress network to numNFTs ids=() amounts=() step=1

    echo "Please enter the following parameters to mint an amount of copies of multiple NFTs to the address:"
    echo -e "contractAddress network to ids amounts\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "To: " to 2 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "To is required." "To must start with '0x' and be 42 characters long."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "How much different NFTs do you want to mint? " numNFTs 3 "true" \
                    '[[ "$input" =~ ^[0-9]+$ ]]' "Number of different NFTs is required." "Please enter an integer value."
                _step_back && continue
                if [[ "$numNFTs" -lt 2 || "$numNFTs" -gt 10 ]]; then
                    echo "You can mint between 2 and 10 different NFTs in a single batch."; continue
                fi
                step=5
                ;;
            5)
                local i=1
                ids=() amounts=()
                while (( i <= numNFTs )); do
                    [[ -z "${ids[i-1]}" ]] && {
                        read -e -p "Token ID for NFT $i: " input
                        [[ -z "$input" ]] && { echo "Token ID is required."; continue; }
                        [[ "$input" =~ ^(<<|\.\.|!undo|!back|!del)$ ]] && {
                            (( i == 1 )) && { step=4; break; }
                            (( i > 1 )) && ids=("${ids[@]:0:${#ids[@]}-1}") && ((i--))
                            continue
                        }
                        [[ "$input" =~ ^[0-9]+$ ]] && ids+=("$input") || { echo "Token ID must be an integer."; continue; }
                    }
                    [[ -n "${ids[i-1]}" && -z "${amounts[i-1]}" ]] && {
                        read -e -p "Amount for NFT $i: " amount
                        [[ -z "$amount" ]] && { echo "Amount is required."; continue; }
                        [[ "$amount" =~ ^(<<|\.\.|!undo|!back|!del)$ ]] && {
                            ids=("${ids[@]:0:${#ids[@]}-1}") && continue
                        }
                        [[ "$amount" =~ ^[0-9]+$ ]] && amounts+=("$amount") && ((i++)) || { echo "Amount must be an integer."; }
                    }
                done
                (( i > numNFTs )) && step=6
                ;;
            6)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Network: $net_name"
                echo "To: $to"
                for ((i=0; i<numNFTs; i++)); do
                    echo "Token ID $((i+1)): ${ids[i]}"
                    echo "Amount $((i+1)): ${amounts[i]}"
                done
                echo

                _confirmation && step=0 || { [[ $? -eq 99 ]] && step=4 || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local ids_json=$(printf '%s\n' "${ids[@]}" | jq -s '.')
    local amounts_json=$(printf '%s\n' "${amounts[@]}" | jq -s '.')
    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        --arg to "$to" \
        --argjson ids "$ids_json" \
        --argjson amounts "$amounts_json" \
        '{
            contractAddress: $contractAddress,
            network: $network,
            to: $to,
            ids: $ids,
            amounts: $amounts
        }')

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/erc/v1/erc1155/mintbatch' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')

    if [[ -n "$txHash" ]]; then
        echo -e "\nMinting NFTs to: $to"
        _loading
        [[ -n "$url_tx" ]] && echo -e "\nBlock explorer URL:\n$url_tx$txHash"
    fi
}

transfer1155(){ # TRANSFER THE SPECIFIED AMOUNT OF COPIES OF AN NFT TO THE GIVEN ADDRESS

    local contractAddress network to id amount step=1

    echo "Please enter the following parameters to transfer a number of copies of an NFT to the address:"
    echo -e "contractAddress network to id amount\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "To: " to 2 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "To is required." "To must start with '0x' and be 42 characters long."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Token ID: " id 3 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Token ID is required." "Token ID must be an integer number."
                _step_back && continue
                step=5
                ;;
            5)
                _check_input "Amount: " amount 4 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Amount is required." "Amount must be an integer number."
                _step_back && continue
                step=6
                ;;
            6)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Network: $net_name"
                echo "To: $to"
                echo "Token ID: $id"
                echo -e "Amount: $amount\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        --arg to "$to" \
        --argjson id "$id" \
        --argjson amount "$amount" \
        '{
            contractAddress: $contractAddress,
            network: $network,
            to: $to,
            id: $id,
            amount: $amount
        }')

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/erc/v1/erc1155/transfer' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')

    if [[ -n "$txHash" ]]; then
        echo -e "\nSending $amount NFTs with Token ID $id\nto: $to"
        _loading
        [[ -n "$url_tx" ]] && echo -e "\nBlock explorer URL:\n$url_tx$txHash"
    fi
}

transfer_batch(){ # TRANSFER THE SPECIFIED AMOUNT OF COPIES OF MULTIPLE NFTS TO THE GIVEN ADDRESS

    local contractAddress network to numNFTs ids=() amounts=() step=1

    echo "Please enter the following parameters to transfer an amount of copies of multiple NFTs to the address:"
    echo -e "contractAddress network to ids amounts\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "To: " to 2 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "To is required." "To must start with '0x' and be 42 characters long."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "How much different NFTs do you want to transfer? " numNFTs 3 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Number of different NFTs is required." "Please enter an integer value."
                _step_back && continue
                if [[ "$numNFTs" -lt 2 || "$numNFTs" -gt 10 ]]; then
                    echo "You can transfer between 2 and 10 different NFTs in a single batch."
                    continue
                fi
                step=5
                ;;
            5)
                local i=1
                ids=() amounts=()
                while (( i <= numNFTs )); do
                    [[ -z "${ids[i-1]}" ]] && {
                        read -e -p "Token ID for NFT $i: " input
                        [[ -z "$input" ]] && { echo "Token ID is required."; continue; }
                        [[ "$input" =~ ^(<<|\.\.|!undo|!back|!del)$ ]] && {
                            (( i == 1 )) && { step=4; break; }
                            (( i > 1 )) && ids=("${ids[@]:0:${#ids[@]}-1}") && ((i--))
                            continue
                        }
                        [[ "$input" =~ ^[0-9]+$ ]] && ids+=("$input") || { echo "Token ID must be an integer."; continue; }
                    }
                    [[ -n "${ids[i-1]}" && -z "${amounts[i-1]}" ]] && {
                        read -e -p "Amount for NFT $i: " amount
                        [[ -z "$amount" ]] && { echo "Amount is required."; continue; }
                        [[ "$amount" =~ ^(<<|\.\.|!undo|!back|!del)$ ]] && {
                            ids=("${ids[@]:0:${#ids[@]}-1}") && continue
                        }
                        [[ "$amount" =~ ^[0-9]+$ ]] && amounts+=("$amount") && ((i++)) || { echo "Amount must be an integer."; }
                    }
                done
                (( i > numNFTs )) && step=6
                ;;
            6)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Network: $net_name"
                echo "To: $to"
                for ((i=0; i<numNFTs; i++)); do
                    echo "Token ID $((i+1)): ${ids[i]}"
                    echo "Amount $((i+1)): ${amounts[i]}"
                done
                echo
                
                _confirmation && step=0 || { [[ $? -eq 99 ]] && step=4 || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local ids_json=$(printf '%s\n' "${ids[@]}" | jq -s '.')
    local amounts_json=$(printf '%s\n' "${amounts[@]}" | jq -s '.')
    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        --arg to "$to" \
        --argjson ids "$ids_json" \
        --argjson amounts "$amounts_json" \
        '{
            contractAddress: $contractAddress,
            network: $network,
            to: $to,
            ids: $ids,
            amounts: $amounts
        }')

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/erc/v1/erc1155/transferBatch' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')

    if [[ -n "$txHash" ]]; then
        echo -e "\nSending NFTs to: $to"
        _loading
        [[ -n "$url_tx" ]] && echo -e "\nBlock explorer URL:\n$url_tx$txHash"
    fi
}

balance1155(){ # DISPLAY THE AMOUNT OF AN NFT FOR THE GIVEN ADDRESS AND SMART CONTRACT ON A SPECIFIED NETWORK

    local contractAddress network address id step=1

    echo "Please enter the following parameters to display the amount of an NFT for the address:"
    echo -e "contractAddress network address id\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Address: " address 2 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Address is required." "Address must start with '0x' and be 42 characters long."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Token ID: " id 3 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Token ID is required." "Token ID must be an integer number."
                _step_back && continue
                step=5
                ;;
            5)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Network: $net_name"
                echo "Address: $address"
                echo -e "Token ID: $id\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        --arg address "$address" \
        --argjson id "$id" \
        '{
            contractAddress: $contractAddress,
            network: $network,
            address: $address,
            id: $id
        }')

    local response=$(curl --silent --location --request GET 'https://api.vottun.tech/erc/v1/erc1155/balanceOf' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
}

uri1155(){ # DISPLAY THE URI OF THE METADATA FOR THE NFT FROM THE GIVEN CONTRACT

    local contractAddress network id step=1

    echo "Please enter the following parameters to display the URI of the metadata for the NFT from the contract:"
    echo -e "contractAddress network id\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Token ID: " id 2 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Token ID is required." "Token ID must be an integer number."
                _step_back && continue
                step=4
                ;;
            4)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Network: $net_name"
                echo -e "Token ID: $id\n"
                    
                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        --argjson id "$id" \
        '{
            contractAddress: $contractAddress,
            network: $network,
            id: $id
        }')

    local response=$(curl --silent --location --request GET 'https://api.vottun.tech/erc/v1/erc1155/tokenUri' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
}


############
### POAP ###
############

deployPOAP(){ # DEPLOY A POAP SMART CONTRACT AND MINT THE TOKENS

    local name amount ipfsUri network alias gasLimit step=1

    echo "Please enter the following parameters to deploy the POAP contract:"
    echo -e "name amount ipfsUri network alias (gasLimit)\n"

    while true; do
        case $step in
            1)
                _check_input "Name: " name -1 "true" 'true' "Name is required." ""
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Amount: " amount 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Amount is required." "Amount must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "IPFS URI: " ipfsUri 2 "true" '[[ ${#input} -ge 46 ]]' \
                    "IPFS URI is required." "The IPFS URI must be longer."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Network: " network 3 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=5
                ;;
            5)
                _check_input "Alias: " alias 4 "true" 'true' "Alias is required." ""
                _step_back && continue
                step=6
                ;;
            6)
                _check_input "Gas Limit (optional): " gasLimit 5 "false" \
                    '[[ "$input" =~ ^[0-9]+$ ]]' "" "Gas Limit must be an integer number if provided."
                [[ $? -eq 99 ]] && step=5 && continue
                step=7
                ;;
            7)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Name: $name"
                echo "Amount: $amount"
                echo "IPFS URI: $ipfsUri"
                echo "Network: $net_name"
                echo "Alias: $alias"
                [ -n "$gasLimit" ] && echo "Gas Limit: $gasLimit"
                echo

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg name "$name" \
        --argjson amount "$amount" \
        --arg ipfsUri "$ipfsUri" \
        --argjson network "$network" \
        --arg alias "$alias" \
        --arg gasLimit "$gasLimit" \
        '{
            name: $name,
            amount: $amount,
            ipfsUri: $ipfsUri,
            network: $network,
            alias: $alias
        } + 
        (if $gasLimit != "" then {gasLimit: $gasLimit | tonumber} else {} end)')

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/erc/v1/poap/deploy' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')

    if [[ -n "$txHash" ]]; then
        contractAddress=$(echo "$response" | jq -r '.contractAddress // empty')
        echo -e "\nDeploying the POAP contract on $net_name..."
        _loading
        [[ -n "$url_tx" ]] && echo -e "\nBlock explorer URLs:\n$url_address$contractAddress\n$url_tx$txHash"
    fi
}

transferPOAP(){ # TRANSFER AN NFT TO THE GIVEN ADDRESS

    local contractAddress network to id step=1

    echo "Please enter the following parameters to transfer an NFT to the address:"
    echo -e "contractAddress network to id\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "To: " to 2 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "To is required." "To must start with '0x' and be 42 characters long."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Token ID: " id 3 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Token ID is required." "Token ID must be an integer number."
                _step_back && continue
                step=5
                ;;
            5)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Network: $net_name"
                echo "To: $to"
                echo -e "Token ID: $id\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        --arg to "$to" \
        --argjson id "$id" \
        '{
            contractAddress: $contractAddress,
            network: $network,
            to: $to,
            id: $id
        }')

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/erc/v1/poap/transfer' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')

    if [[ -n "$txHash" ]]; then
        echo -e "\nSending NFT with Token ID $id\nto: $to"
        _loading
        [[ -n "$url_tx" ]] && echo -e "\nBlock explorer URL:\n$url_tx$txHash"
    fi
}

balancePOAP(){ # DISPLAY THE AMOUNT OF AN NFT FOR THE GIVEN ADDRESS AND SMART CONTRACT ON A SPECIFIED NETWORK

    local contractAddress network address id step=1

    echo "Please enter the following parameters to display the amount of the NFT for the address:"
    echo -e "contractAddress network address id\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Address: " address 2 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Address is required." "Address must start with '0x' and be 42 characters long."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Token ID: " id 3 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Token ID is required." "Token ID must be an integer number."
                _step_back && continue
                step=5
                ;;
            5)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Network: $net_name"
                echo "Address: $address"
                echo -e "Token ID: $id\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --argjson network "$network" \
        --arg address "$address" \
        --argjson id "$id" \
        '{
            contractAddress: $contractAddress,
            network: $network,
            address: $address,
            id: $id
        }')

    local response=$(curl --silent --location --request GET 'https://api.vottun.tech/erc/v1/poap/balanceOf' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
}

uriPOAP(){ # DISPLAY THE URI OF THE METADATA FOR THE NFT FROM THE GIVEN CONTRACT

    uri1155
}


#########################
### CUSTODIED WALLETS ###
#########################

new_wallet() { # GENERATES A ONE-TIME-USE HASH AND RETRIEVES THE URL TO CREATE A NEW CUSTODIED WALLET

    local callback_url fallback_url cancel_url

    callback_url="https://callback.vottun.tech/rest/v1/success/"
    fallback_url="https://fallback.vottun.tech/rest/v1/error/"
    cancel_url="https://fallback.vottun.tech/rest/v1/cancel/"

    local data=$(jq -n \
        --arg email "$email" \
        --arg callback_url "$callback_url" \
        --arg fallback_url "$fallback_url" \
        --arg cancel_url "$cancel_url" \
        '{
            "username": $email,
            "strategies": [2, 3],
            "callbackUrl": $callback_url,
            "fallbackUrl": $fallback_url,
            "cancelUrl": $cancel_url
        }')

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/cwll/v1/hash/new' \
        "${auth[@]}" $ct_json --data-raw "$data")

    local hash=$(echo "$response" | jq -r '.hash // empty')

    if [[ -n "$hash" ]]; then
        echo "To complete the creation of your new custodied wallet, please visit:"
        echo -e "\nhttps://wallet.vottun.io/?hash=${hash}&username=${email}"
    else
        echo "Error: Unable to retrieve the hash from the server response."
    fi
}

get_address() { # RETRIEVE THE WALLET'S PUBLIC ADDRESS (FOR THE 1ST ACCOUNT) FOR ONE OF OUR USERS

    echo -e "Retrieving the wallet's public address for your 1st account...\n"

    local response=$(curl --silent --location --request GET 'https://api.vottun.tech/cwll/v1/evm/wallet/custodied/address' \
        "${auth[@]}" $ct_json --data-raw '{"userEmail": "'"$email"'"}')

    echo "$response"
}

get_wallets() { # RETRIEVE ALL CUSTODIED WALLETS CREATED FOR YOU

    echo -e "Retrieving your custodied wallets...\n"

    curl --location --request GET 'https://api.vottun.tech/cwll/v1/evm/wallet/custodied/list' "${auth[@]}"

    echo
}

otp() { # REQUEST A ONE-TIME EMAIL OTP TO SIGN A MUTABLE TRANSACTION WITHIN THE NEXT 120 SECONDS

    curl --location --request POST 'https://api.vottun.tech/cwll/v1/2fa/signature/otp/new?email='$email'' "${auth[@]}"

    echo "Requesting OTP... Check your email inbox! ✉"
}

send_tx() { # CALL ANY PUBLIC FUNCTION IMPLEMENTED IN A SMART CONTRACT AND MODIFY ITS STATE (FOR VIEW OR PURE FUNCTIONS, USE "query" IN WEB3 CORE)

    local contractAddress contractSpecsId sender strategy blockchainNetwork method numParams params value myReference gasLimit gasPrice nonce pin step=1

    echo "Please enter the following parameters to call the function:"
    echo -e "contractAddress sender strategy network method params pin (contractSpecsId) (amount) (myReference) (gasLimit) (gasPrice) (nonce)\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                _step_back && continue
                step=2
                ;;
            2)
                _check_input "Contract Specs ID (optional): " contractSpecsId 1 "false" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "" "Contract Specs ID must be an integer number if provided."
                _step_back && continue
                step=3
                ;;
            3)
                while true; do
                    wallets_response=$(curl --silent --location --request GET 'https://api.vottun.tech/cwll/v1/evm/wallet/custodied/list' "${auth[@]}")
                    wallet_data=$(echo "$wallets_response" | jq -r '.[] | [.accountHash, .strategy] | @tsv')

                    if [[ -z "$wallet_data" ]]; then
                        echo "No wallets found... Please input the sender address manually."
                        while true; do
                            _check_input "Sender: " sender 3 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                                "Sender is required." "Sender must start with '0x' and be 42 characters long." || continue
                            _check_input "Strategy ('2' for 2FA or '3' for OTP): " strategy 3 "true" \
                                '[[ "$input" =~ ^(2|3)$ ]]' "Strategy is required." "Strategy must be '2' or '3'." || continue
                            step=4 && break 2
                        done
                    else
                        declare -A wallet_map
                        echo "Select the sender address you want to use..."
                        i=1
                        while IFS=$'\t' read -r accountHash wallet_strategy; do
                            wallet_map["$i"]="$accountHash $wallet_strategy"
                            echo "$i. $accountHash"
                            ((i++))
                        done <<< "$wallet_data"
                        echo "$i. Input manually."

                        while true; do
                            _check_input "Enter the number of your choice: " choice 2 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                                "Choice is required." "Choice must be a valid number." || { step=2; break 2; }

                            if [[ "$choice" -ge 1 && "$choice" -lt "$i" ]]; then
                                IFS=' ' read -r sender strategy <<< "${wallet_map["$choice"]}"
                                echo -e "Sender: $sender\nStrategy: $strategy"
                                step=4 && break 2
                            elif [[ "$choice" -eq "$i" ]]; then
                                while true; do
                                    _check_input "Sender: " sender 3 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                                        "Sender is required." "Sender must start with '0x' and be 42 characters long." || continue 3
                                    _check_input "Strategy ('2' for 2FA or '3' for OTP): " strategy 3 "true" \
                                        '[[ "$input" =~ ^(2|3)$ ]]' "Strategy is required." "Strategy must be '2' or '3'." || continue
                                    step=4 && break 2
                                done
                                break
                            else
                                echo "Invalid choice! Please try again."
                            fi
                        done
                    fi
                    [[ -n "$sender" && -n "$strategy" ]] && break
                done
                pin_label=$([[ "$strategy" -eq 2 ]] && echo "2FA" || echo "OTP")
                ;;
            4)
                _check_input "Network: " blockchainNetwork 3 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=5
                ;;
            5)
                _check_input "Method: " method 4 "true" '[[ "$input" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]' \
                    "Method is required." "Method format is wrong."
                _step_back && continue
                step=6
                ;;
            6)
                _check_input "How many parameters do you want to input? " numParams 5 "false" \
                    '[[ "$input" =~ ^[0-9]+$ ]]' "" "Please enter a valid integer."
                _step_back && continue
                numParams=${numParams:-0}
                params=()
                step=7
                ;;
            7)
                local i=1
                while (( i <= numParams )); do
                    read -e -p "Param $i: " input
                    if [[ "$input" =~ ^(<<|\.\.|!undo|!back|!del)$ ]]; then
                        if (( i == 1 )); then
                            step=6 && break
                        elif (( i > 1 )); then
                            params=("${params[@]:0:${#params[@]}-1}") && ((i--))
                        fi
                    elif [[ -n "$input" ]]; then
                        params+=("$input") && ((i++))
                    else
                        echo "Parameter $i is required."
                    fi
                done
                (( i > numParams )) && step=8
                ;;
            8)
                _check_input "Amount of native tokens (optional): " value 6 "false" \
                    '[[ "$input" =~ ^[0-9]*\.?[0-9]+$ ]]' "" "Amount must be a valid integer or decimal if provided."
                [[ $? -eq 99 ]] && step=6 && continue
                [[ -z "$value" ]] && value=${value:-0}
                value_wei=$(echo "$value * 10^18 / 1" | bc)
                step=9
                ;;
            9)
                _check_input "Reference (optional): " myReference 8 "false" '' "" ""
                _step_back && continue
                step=10
                ;;
            10)
                _check_input "Gas Limit (optional): " gasLimit 9 "false" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "" "Gas Limit must be an integer number if provided."
                _step_back && continue
                step=11
                ;;
            11)
                gasPrice="" nonce=""
                _check_input "Are you aiming to accelerate or cancel a transaction? (Y/N): " confirm 10 "false" \
                    '[[ "$input" =~ ^[YyNn]$ ]]' "" "Invalid input! Please choose 'Y' or 'N'."
                _step_back && continue                
                [[ "$confirm" =~ ^[Yy]$ ]] && { flag=1; step=12; } || { flag=0; step=14; }
                ;;
            12)
                _check_input "Gas Price: " gasPrice 11 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Gas Price is required to accelerate or cancel the transaction." "Gas Price must be an integer number."
                _step_back && continue
                step=13
                ;;
            13)
                _check_input "Nonce: " nonce 12 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Nonce is required to accelerate or cancel the transaction." "Nonce must be an integer number."
                _step_back && continue
                step=14
                ;;
            14)
                [[ "$strategy" == 3 ]] && otp
                _check_input "$pin_label: " pin 13 "true" '[[ "$input" =~ ^[0-9]{6}$ ]]' \
                    "$pin_label is required." "$pin_label must be a 6-digit number."                                                
                [[ $? -eq 99 ]] && { step=$((flag == 1 ? 13 : 11)); continue; }
                step=15
                ;;
            15)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$blockchainNetwork")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                [ -n "$contractSpecsId" ] && echo "Contract Specs ID: $contractSpecsId"
                echo "Sender: $sender"
                echo "Network: $net_name"
                echo "Method: $method"
                local final_params=$(jq -n '[]')
                parse_structure() {
                    local input="$1"
                    if [[ "$input" =~ ^\[.*\]$ ]]; then
                        local result=$(jq -n '[]') trimmed=$(echo "$input" | sed -E 's/^\[|\]$//g') buffer="" depth=0
                        while IFS= read -r -n1 char; do
                            [[ "$char" == "[" ]] && ((depth++))
                            [[ "$char" == "]" ]] && ((depth--))
                            if [[ "$char" == "," && $depth -eq 0 ]]; then
                                result=$(echo "$result" | jq ". + [$(parse_structure "$buffer")]") && buffer=""
                            else
                                buffer+="$char"
                            fi
                        done <<< "$trimmed"
                        [[ -n "$buffer" ]] && result=$(echo "$result" | jq ". + [$(parse_structure "$buffer")]")
                        echo "$result"
                    elif [[ "$input" =~ ^[0-9]+$|^(true|false)$ ]]; then
                        echo "$input"
                    else
                        echo "\"$input\""
                    fi
                }
                for param in "${params[@]}"; do
                    final_params=$(echo "$final_params" | jq ". + [$(parse_structure "$param")]")
                done
                [[ ${#params[@]} -gt 0 ]] && {
                    local display_params=$(jq -n '[]')
                    for param in "${params[@]}"; do
                        display_params=$(echo "$display_params" | jq ". + [$(parse_structure "$param")]")
                    done
                    display_params=$(echo "$display_params" | jq -r '. | map(
                        if type == "array" or type == "number" or type == "boolean" then tostring else "\"\(.)\"" end
                        ) | join(", ")')
                    echo "Params: [$display_params]"
                }
                echo "$pin_label: $pin"
                [[ -n "$value" && "$value" -gt 0 ]] && echo "Amount: $value"
                [ -n "$myReference" ] && echo "Reference: $myReference"
                [ -n "$gasLimit" ] && echo "Gas Limit: $gasLimit"
                [ -n "$gasPrice" ] && echo "Gas Price: $gasPrice"
                [ -n "$nonce" ] && echo "Nonce: $nonce"
                echo

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --arg contractSpecsId "$contractSpecsId" \
        --arg sender "$sender" \
        --argjson blockchainNetwork "$blockchainNetwork" \
        --arg method "$method" \
        --arg pin "$pin" \
        --arg myReference "$myReference" \
        --arg gasLimit "$gasLimit" \
        --arg gasPrice "$gasPrice" \
        --arg nonce "$nonce" \
        '{
            contractAddress: $contractAddress,
            sender: $sender,
            blockchainNetwork: $blockchainNetwork,
            method: $method,
            pin: $pin
        } +
        (if $contractSpecsId != "" then {contractSpecsId: $contractSpecsId | tonumber} else {} end) +
        (if $myReference != "" then {myReference: $myReference} else {} end) +
        (if $gasLimit != "" then {gasLimit: $gasLimit | tonumber} else {} end) +
        (if $gasPrice != "" then {gasPrice: $gasPrice | tonumber} else {} end) +
        (if $nonce != "" then {nonce: $nonce | tonumber} else {} end)')
    [[ -n "$value" ]] && data=$(echo "$data" | sed "s/^{/{\"value\":$value_wei, /")
    data=$(echo "$data" | jq --argjson params "$final_params" '. + {params: $params}')

    local response=$(curl --silent --location --request POST \
        'https://api.vottun.tech/core/v1/evm/wallet/custodied/transact/mutable?strategy='$strategy'' \
        "${auth[@]}" $ct_json --data-raw "$data")

    _loading
    echo -e "\nServer response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')
    [[ -n "$txHash" && -n "$url_tx" ]] && echo -e "\nBlock explorer URL:\n$url_tx$txHash"
}

send_nat() { # TRANSFER NATIVE ASSETS FROM YOU CUSTODIED WALLET

    local sender strategy recipient blockchainNetwork value myReference gasLimit gasPrice nonce pin step=1

    echo "Please enter the following parameters to transfer native assets:"
    echo -e "sender strategy recipient network amount pin (myReference) (gasLimit) (gasPrice) (nonce)\n"

    while true; do
        case $step in
            1)
                while true; do
                    wallets_response=$(curl --silent --location --request GET 'https://api.vottun.tech/cwll/v1/evm/wallet/custodied/list' "${auth[@]}")
                    wallet_data=$(echo "$wallets_response" | jq -r '.[] | [.accountHash, .strategy] | @tsv')

                    if [[ -z "$wallet_data" ]]; then
                        echo "No wallets found... Please input the sender address manually."
                        while true; do
                            _check_input "Sender: " sender 1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                                "Sender is required." "Sender must start with '0x' and be 42 characters long." || continue
                            _check_input "Strategy ('2' for 2FA or '3' for OTP): " strategy 1 "true" \
                                '[[ "$input" =~ ^(2|3)$ ]]' "Strategy is required." "Strategy must be '2' or '3'." || continue
                            step=2 && break 2
                        done
                    else
                        declare -A wallet_map
                        echo "Select the sender address you want to use..."
                        i=1
                        while IFS=$'\t' read -r accountHash wallet_strategy; do
                            wallet_map["$i"]="$accountHash $wallet_strategy"
                            echo "$i. $accountHash"
                            ((i++))
                        done <<< "$wallet_data"
                        echo "$i. Input manually."

                        while true; do
                            _check_input "Enter the number of your choice: " choice -1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                                "Choice is required." "Choice must be a valid number." || continue

                            if [[ "$choice" -ge 1 && "$choice" -lt "$i" ]]; then
                                IFS=' ' read -r sender strategy <<< "${wallet_map["$choice"]}"
                                echo -e "Sender: $sender\nStrategy: $strategy"
                                step=2 && break 2
                            elif [[ "$choice" -eq "$i" ]]; then
                                while true; do
                                    _check_input "Sender: " sender 1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                                        "Sender is required." "Sender must start with '0x' and be 42 characters long." || continue 3
                                    _check_input "Strategy ('2' for 2FA or '3' for OTP): " strategy 1 "true" \
                                        '[[ "$input" =~ ^(2|3)$ ]]' "Strategy is required." "Strategy must be '2' or '3'." || continue
                                    step=2 && break 2
                                done
                                break
                            else
                                echo "Invalid choice! Please try again."
                            fi
                        done
                    fi
                    [[ -n "$sender" && -n "$strategy" ]] && break
                done
                pin_label=$([[ "$strategy" -eq 2 ]] && echo "2FA" || echo "OTP")
                ;;
            2)
                _check_input "Recipient: " recipient 1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Recipient is required." "Recipient must start with '0x' and be 42 characters long."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Network: " blockchainNetwork 2 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Amount: " value 3 "true" '[[ "$input" =~ ^[0-9]*\.?[0-9]+$ ]]' \
                    "Amount is required." "Amount must be a valid integer or decimal."
                _step_back && continue
                value_wei=$(echo "$value * 10^18 / 1" | bc)
                step=5
                ;;
            5)
                _check_input "Reference (optional): " myReference 4 "false" '' "" ""
                _step_back && continue
                step=6
                ;;
            6)
                _check_input "Gas Limit (optional): " gasLimit 5 "false" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "" "Gas Limit must be an integer number if provided."
                _step_back && continue
                step=7
                ;;
            7)
                gasPrice="" nonce=""
                _check_input "Are you aiming to accelerate or cancel a transaction? (Y/N): " confirm 6 "false" \
                    '[[ "$input" =~ ^[YyNn]$ ]]' "" "Invalid input! Please choose 'Y' or 'N'."
                _step_back && continue               
                [[ "$confirm" =~ ^[Yy]$ ]] && { flag=1; step=8; } || { flag=0; step=10; }
                ;;
            8)
                _check_input "Gas Price: " gasPrice 7 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Gas Price is required to accelerate or cancel the transaction." "Gas Price must be an integer number."
                _step_back && continue
                step=9
                ;;
            9)
                _check_input "Nonce: " nonce 8 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Nonce is required to accelerate or cancel the transaction." "Nonce must be an integer number."
                _step_back && continue
                step=10
                ;;
            10)
                [[ "$strategy" == 3 ]] && otp
                _check_input "$pin_label: " pin 9 "true" '[[ "$input" =~ ^[0-9]{6}$ ]]' \
                    "$pin_label is required." "$pin_label must be a 6-digit number."                                               
                [[ $? -eq 99 ]] && { step=$((flag == 1 ? 9 : 7)); continue; }
                step=11
                ;;
            11)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$blockchainNetwork")"
                echo -e "\nYou've entered the following parameters:"
                echo "Sender: $sender"
                echo "Recipient: $recipient"
                echo "Network: $net_name"
                echo "Amount: $value $currency"
                echo "$pin_label: $pin"
                [ -n "$myReference" ] && echo "Reference: $myReference"
                [ -n "$gasLimit" ] && echo "Gas Limit: $gasLimit"
                [ -n "$gasPrice" ] && echo "Gas Price: $gasPrice"
                [ -n "$nonce" ] && echo "Nonce: $nonce"
                echo

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg sender "$sender" \
        --arg recipient "$recipient" \
        --argjson blockchainNetwork "$blockchainNetwork" \
        --arg pin "$pin" \
        --arg myReference "$myReference" \
        --arg gasLimit "$gasLimit" \
        --arg gasPrice "$gasPrice" \
        --arg nonce "$nonce" \
        '{
            sender: $sender,
            recipient: $recipient,
            blockchainNetwork: $blockchainNetwork,
            pin: $pin
        } +
        (if $myReference != "" then {myReference: $myReference} else {} end) +
        (if $gasLimit != "" then {gasLimit: $gasLimit | tonumber} else {} end) +
        (if $gasPrice != "" then {gasPrice: $gasPrice | tonumber} else {} end) +
        (if $nonce != "" then {nonce: $nonce | tonumber} else {} end)')
    data=$(echo "$data" | sed "s/^{/{\"value\":$value_wei, /")

    local response=$(curl --silent --location --request POST \
        'https://api.vottun.tech/core/v1/evm/wallet/custodied/transfer?strategy='$strategy'' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')

    if [[ -n "$txHash" ]]; then
        echo -e "\nSending: $value $currency\nfrom: $sender\nto: $recipient"
        _loading
        [[ -n "$url_tx" ]] && echo -e "\nBlock explorer URL:\n$url_tx$txHash"
    fi
}


#################
### WEB3 CORE ###    
#################

deploy() { # DEPLOY A SMART CONTRACT ON THE BLOCKCHAIN OF YOUR CHOICE

    local contractSpecsId sender blockchainNetwork method numParams params myReference gasPrice nonce gasLimit useGasEstimation priorityFee step=1

    echo "Please enter the following parameters to call the function:"
    echo -e "contractSpecsId sender network params (gasPrice) (nonce) (myReference) (gasLimit) (useGasEstimation) (priorityFee) (alias)\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Specs ID: " contractSpecsId -1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Contract Specs ID is required." "Contract Specs ID must be an integer number."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Sender: " sender 1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Sender is required." "Sender must start with '0x' and be 42 characters long."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Network: " blockchainNetwork 2 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "How many parameters do you want to input? " numParams 3 "false" \
                    '[[ "$input" =~ ^[0-9]+$ ]]' "" "Please enter a valid integer."
                _step_back && continue
                numParams=${numParams:-0}
                params=()
                step=5
                ;;
            5)
                local i=1
                while (( i <= numParams )); do
                    read -e -p "Param $i: " input
                    if [[ "$input" =~ ^(<<|\.\.|!undo|!back|!del)$ ]]; then
                        if (( i == 1 )); then
                            step=4 && break
                        elif (( i > 1 )); then
                            params=("${params[@]:0:${#params[@]}-1}") && ((i--))
                        fi
                    elif [[ -n "$input" ]]; then
                        params+=("$input") && ((i++))
                    else
                        echo "Parameter $i is required."
                    fi
                done
                (( i > numParams )) && step=6
                ;;
            6)
                gasPrice="" nonce=""
                _check_input "Are you aiming to accelerate or cancel a transaction? (Y/N): " confirm 4 "false" \
                    '[[ "$input" =~ ^[YyNn]$ ]]' "" "Invalid input! Please choose 'Y' or 'N'."
                [[ $? -eq 99 ]] && step=4 && continue            
                [[ "$confirm" =~ ^[Yy]$ ]] && { flag=1; step=7; } || { flag=0; step=9; }
                ;;
            7)
                _check_input "Gas Price: " gasPrice 6 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Gas Price is required to accelerate or cancel the transaction." "Gas Price must be an integer number."
                _step_back && continue
                step=8
                ;;
            8)
                _check_input "Nonce: " nonce 7 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Nonce is required to accelerate or cancel the transaction." "Nonce must be an integer number."
                _step_back && continue
                step=9
                ;;
            9)
                _check_input "Reference (optional): " myReference 8 "false" '' "" ""             
                [[ $? -eq 99 ]] && { step=$((flag == 1 ? 8 : 6)); continue; }
                step=10
                ;;
            10)
                _check_input "Gas Limit (optional): " gasLimit 9 "false" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "" "Gas Limit must be an integer number if provided."
                _step_back && continue
                step=11
                ;;
            11)
                _check_input "Use Gas Estimation? (optional) (Y/N): " useGasEstimation 10 "false" \
                    '[[ "$input" =~ ^[YyNn]$ ]]' "" "Please type 'Y' or 'N' if provided ('true' by default)."
                _step_back && continue
                [[ "$useGasEstimation" =~ ^[Nn]$ ]] && useGasEstimation="false"
                step=12
                ;;
            12)
                _check_input "Priority Fee in Gwei (optional): " priorityFee 11 "false" \
                    '[[ "$input" =~ ^[0-9]*\.?[0-9]+$ ]]' "" "Priority Fee must be a number if provided."
                _step_back && continue
                step=13
                ;;
            13)
                _check_input "Alias (optional): " alias 12 "false" 'true' "" ""
                _step_back && continue
                step=14
                ;;
            14)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$blockchainNetwork")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Specs ID: $contractSpecsId"
                echo "Sender: $sender"
                echo "Network: $net_name"
                local final_params=$(jq -n '[]')
                parse_structure() {
                    local input="$1"
                    if [[ "$input" =~ ^\[.*\]$ ]]; then
                        local result=$(jq -n '[]') trimmed=$(echo "$input" | sed -E 's/^\[|\]$//g') buffer="" depth=0
                        while IFS= read -r -n1 char; do
                            [[ "$char" == "[" ]] && ((depth++))
                            [[ "$char" == "]" ]] && ((depth--))
                            if [[ "$char" == "," && $depth -eq 0 ]]; then
                                result=$(echo "$result" | jq ". + [$(parse_structure "$buffer")]") && buffer=""
                            else
                                buffer+="$char"
                            fi
                        done <<< "$trimmed"
                        [[ -n "$buffer" ]] && result=$(echo "$result" | jq ". + [$(parse_structure "$buffer")]")
                        echo "$result"
                    elif [[ "$input" =~ ^[0-9]+$|^(true|false)$ ]]; then
                        echo "$input"
                    else
                        echo "\"$input\""
                    fi
                }
                for param in "${params[@]}"; do
                    final_params=$(echo "$final_params" | jq ". + [$(parse_structure "$param")]")
                done
                [[ ${#params[@]} -gt 0 ]] && {
                    local display_params=$(jq -n '[]')
                    for param in "${params[@]}"; do
                        display_params=$(echo "$display_params" | jq ". + [$(parse_structure "$param")]")
                    done
                    display_params=$(echo "$display_params" | jq -r '. | map(
                        if type == "array" or type == "number" or type == "boolean" then tostring else "\"\(.)\"" end
                        ) | join(", ")')
                    echo "Params: [$display_params]"
                }
                [ -n "$gasPrice" ] && echo "Gas Price: $gasPrice"
                [ -n "$nonce" ] && echo "Nonce: $nonce"
                [ -n "$myReference" ] && echo "Reference: $myReference"
                [ -n "$gasLimit" ] && echo "Gas Limit: $gasLimit"
                [ -n "$useGasEstimation" ] && echo "Gas Estimation: $useGasEstimation"
                [ -n "$priorityFee" ] && echo "Priority Fee: $priorityFee"
                [ -n "$alias" ] && echo "Alias: $alias"
                echo

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --argjson contractSpecsId "$contractSpecsId" \
        --arg sender "$sender" \
        --argjson blockchainNetwork "$blockchainNetwork" \
        --arg gasPrice "$gasPrice" \
        --arg nonce "$nonce" \
        --arg myReference "$myReference" \
        --arg gasLimit "$gasLimit" \
        --arg useGasEstimation "$useGasEstimation" \
        --arg priorityFee "$priorityFee" \
        --arg alias "$alias" \
        '{
            contractSpecsId: $contractSpecsId,
            sender: $sender,
            blockchainNetwork: $blockchainNetwork
        } +
        (if $gasPrice != "" then {gasPrice: $gasPrice | tonumber} else {} end) +
        (if $nonce != "" then {nonce: $nonce | tonumber} else {} end) +
        (if $myReference != "" then {myReference: $myReference} else {} end) +
        (if $gasLimit != "" then {gasLimit: $gasLimit | tonumber} else {} end) +
        (if $useGasEstimation != "" then {useGasEstimation: ($useGasEstimation | test("^true$"))} else {} end) +
        (if $priorityFee != "" then {priorityFee: $priorityFee | tonumber} else {} end) +
        (if $alias != "" then {alias: $alias} else {} end)')
    data=$(echo "$data" | jq --argjson params "$final_params" '. + {params: $params}')

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/core/v1/evm/contract/deploy' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')

    if [[ -n "$txHash" ]]; then
        contractAddress=$(echo "$response" | jq -r '.contractAddress // empty')
        echo -e "\nDeploying the smart contract on $net_name..."
        _loading
        [[ -n "$url_tx" ]] && echo -e "\nBlock explorer URLs:\n$url_address$contractAddress\n$url_tx$txHash"
    fi
}

call_function() { # CALL ANY PUBLIC FUNCTION IMPLEMENTED IN A SMART CONTRACT AND MODIFY ITS STATE (FOR VIEW OR PURE FUNCTIONS, USE "query")

    local contractAddress contractSpecsId sender blockchainNetwork method numParams params value myReference gasPrice nonce gasLimit useGasEstimation priorityFee step=1

    echo "Please enter the following parameters to call the function:"
    echo -e "contractAddress sender network method params (contractSpecsId) (amount) (gasPrice) (nonce) (myReference) (gasLimit) (useGasEstimation) (priorityFee)\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Contract Specs ID (optional): " contractSpecsId 1 "false" \
                    '[[ "$input" =~ ^[0-9]+$ ]]' "" "Contract Specs ID must be an integer number if provided."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Sender: " sender 2 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Sender is required." "Sender must start with '0x' and be 42 characters long."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Network: " blockchainNetwork 3 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=5
                ;;
            5)
                _check_input "Method: " method 4 "true" '[[ "$input" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]' \
                    "Method is required." "Method format is wrong."
                _step_back && continue
                step=6
                ;;
            6)
                _check_input "How many parameters do you want to input? " numParams 5 "false" \
                    '[[ "$input" =~ ^[0-9]+$ ]]' "" "Please enter a valid integer."
                _step_back && continue
                numParams=${numParams:-0}
                params=()
                step=7
                ;;
            7)
                local i=1
                while (( i <= numParams )); do
                    read -e -p "Param $i: " input
                    if [[ "$input" =~ ^(<<|\.\.|!undo|!back|!del)$ ]]; then
                        if (( i == 1 )); then
                            step=6 && break
                        elif (( i > 1 )); then
                            params=("${params[@]:0:${#params[@]}-1}") && ((i--))
                        fi
                    elif [[ -n "$input" ]]; then
                        params+=("$input") && ((i++))
                    else
                        echo "Parameter $i is required."
                    fi
                done
                (( i > numParams )) && step=8
                ;;
            8)
                _check_input "Amount of native tokens (optional): " value 6 "false" \
                    '[[ "$input" =~ ^[0-9]*\.?[0-9]+$ ]]' "" "Amount must be a valid integer or decimal if provided."
                [[ $? -eq 99 ]] && step=6 && continue
                [[ -z "$value" ]] && value=${value:-0}
                value_wei=$(echo "$value * 10^18 / 1" | bc)
                step=9
                ;;
            9)
                gasPrice="" nonce=""
                _check_input "Are you aiming to accelerate or cancel a transaction? (Y/N): " confirm 8 "false" \
                    '[[ "$input" =~ ^[YyNn]$ ]]' "" "Invalid input! Please choose 'Y' or 'N'."
                _step_back && continue             
                [[ "$confirm" =~ ^[Yy]$ ]] && { flag=1; step=10; } || { flag=0; step=12; }
                ;;
            10)
                _check_input "Gas Price: " gasPrice 9 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Gas Price is required to accelerate or cancel the transaction." "Gas Price must be an integer number."
                _step_back && continue
                step=11
                ;;
            11)
                _check_input "Nonce: " nonce 10 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Nonce is required to accelerate or cancel the transaction." "Nonce must be an integer number."
                _step_back && continue
                step=12
                ;;
            12)
                _check_input "Reference (optional): " myReference 11 "false" '' "" ""             
                [[ $? -eq 99 ]] && { step=$((flag == 1 ? 11 : 9)); continue; }
                step=13
                ;;
            13)
                _check_input "Gas Limit (optional): " gasLimit 12 "false" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "" "Gas Limit must be an integer number if provided."
                _step_back && continue               
                step=14
                ;;
            14)
                _check_input "Use Gas Estimation? (optional) (Y/N): " useGasEstimation 13 "false" \
                    '[[ "$input" =~ ^[YyNn]$ ]]' "" "Please type 'Y' or 'N' if provided ('true' by default)."
                _step_back && continue
                [[ "$useGasEstimation" =~ ^[Nn]$ ]] && useGasEstimation="false"
                step=15
                ;;
            15)
                _check_input "Priority Fee in Gwei (optional): " priorityFee 14 "false" \
                    '[[ "$input" =~ ^[0-9]*\.?[0-9]+$ ]]' "" "Priority Fee must be a number if provided."
                _step_back && continue
                step=16
                ;;
            16)                
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$blockchainNetwork")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                [ -n "$contractSpecsId" ] && echo "Contract Specs ID: $contractSpecsId"
                echo "Sender: $sender"
                echo "Network: $net_name"
                echo "Method: $method"
                local final_params=$(jq -n '[]')
                parse_structure() {
                    local input="$1"
                    if [[ "$input" =~ ^\[.*\]$ ]]; then
                        local result=$(jq -n '[]') trimmed=$(echo "$input" | sed -E 's/^\[|\]$//g') buffer="" depth=0
                        while IFS= read -r -n1 char; do
                            [[ "$char" == "[" ]] && ((depth++))
                            [[ "$char" == "]" ]] && ((depth--))
                            if [[ "$char" == "," && $depth -eq 0 ]]; then
                                result=$(echo "$result" | jq ". + [$(parse_structure "$buffer")]") && buffer=""
                            else
                                buffer+="$char"
                            fi
                        done <<< "$trimmed"
                        [[ -n "$buffer" ]] && result=$(echo "$result" | jq ". + [$(parse_structure "$buffer")]")
                        echo "$result"
                    elif [[ "$input" =~ ^[0-9]+$|^(true|false)$ ]]; then
                        echo "$input"
                    else
                        echo "\"$input\""
                    fi
                }
                for param in "${params[@]}"; do
                    final_params=$(echo "$final_params" | jq ". + [$(parse_structure "$param")]")
                done
                [[ ${#params[@]} -gt 0 ]] && {
                    local display_params=$(jq -n '[]')
                    for param in "${params[@]}"; do
                        display_params=$(echo "$display_params" | jq ". + [$(parse_structure "$param")]")
                    done
                    display_params=$(echo "$display_params" | jq -r '. | map(
                        if type == "array" or type == "number" or type == "boolean" then tostring else "\"\(.)\"" end
                        ) | join(", ")')
                    echo "Params: [$display_params]"
                }
                [[ -n "$value" && "$value" -gt 0 ]] && echo "Amount of native tokens: $value $currency"
                [ -n "$gasPrice" ] && echo "Gas Price: $gasPrice"
                [ -n "$nonce" ] && echo "Nonce: $nonce"
                [ -n "$myReference" ] && echo "Reference: $myReference"
                [ -n "$gasLimit" ] && echo "Gas Limit: $gasLimit"
                [ -n "$useGasEstimation" ] && echo "Gas Estimation: $useGasEstimation"
                [ -n "$priorityFee" ] && echo "Priority Fee: $priorityFee"
                echo

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --arg contractSpecsId "$contractSpecsId" \
        --arg sender "$sender" \
        --argjson blockchainNetwork "$blockchainNetwork" \
        --arg method "$method" \
        --arg gasPrice "$gasPrice" \
        --arg nonce "$nonce" \
        --arg myReference "$myReference" \
        --arg gasLimit "$gasLimit" \
        --arg useGasEstimation "$useGasEstimation" \
        --arg priorityFee "$priorityFee" \
        '{
            contractAddress: $contractAddress,
            sender: $sender,
            blockchainNetwork: $blockchainNetwork,
            method: $method
        } +
        (if $contractSpecsId != "" then {contractSpecsId: $contractSpecsId | tonumber} else {} end) +
        (if $gasPrice != "" then {gasPrice: $gasPrice | tonumber} else {} end) +
        (if $nonce != "" then {nonce: $nonce | tonumber} else {} end) +
        (if $myReference != "" then {myReference: $myReference} else {} end) +
        (if $gasLimit != "" then {gasLimit: $gasLimit | tonumber} else {} end) +
        (if $useGasEstimation != "" then {useGasEstimation: ($useGasEstimation | test("^true$"))} else {} end) +
        (if $priorityFee != "" then {priorityFee: $priorityFee | tonumber} else {} end)')
    [ -n "$value" ] && data=$(echo "$data" | sed "s/^{/{\"value\":$value_wei, /")
    data=$(echo "$data" | jq --argjson params "$final_params" '. + {params: $params}')

    local response=$(curl --silent --location --request POST 'https://api.vottun.tech/core/v1/evm/transact/mutable' \
        "${auth[@]}" $ct_json --data-raw "$data")

    _loading
    echo -e "\nServer response:\n$response"
    txHash=$(echo "$response" | jq -r '.txHash // empty')
    [[ -n "$txHash" && -n "$url_tx" ]] && echo -e "\nBlock explorer URL:\n$url_tx$txHash"
}

query() { # CALL ANY PUBLIC FUNCTION IMPLEMENTED IN A SMART CONTRACT WITHOUT CHANGE ITS STATE (VIEW OR PURE FUNCTIONS)

    local contractAddress contractSpecsId blockchainNetwork method numParams params step=1

    echo "Please enter the following parameters to call the view or pure function:"
    echo -e "contractAddress network method params (contractSpecsId)\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Contract Specs ID (optional): " contractSpecsId 1 "false" \
                    '[[ "$input" =~ ^[0-9]+$ ]]' "" "Contract Specs ID must be an integer number if provided."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Network: " blockchainNetwork 2 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Method: " method 3 "true" '[[ "$input" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]' \
                    "Method is required." "Method format is wrong."
                _step_back && continue
                step=5
                ;;
            5)
                _check_input "How many parameters do you want to input? " numParams 4 "false" \
                    '[[ "$input" =~ ^[0-9]+$ ]]' "" "Please enter a valid integer."
                _step_back && continue
                numParams=${numParams:-0}
                params=()
                step=6
                ;;
            6)
                local i=1
                while (( i <= numParams )); do
                    read -e -p "Param $i: " input
                    if [[ "$input" =~ ^(<<|\.\.|!undo|!back|!del)$ ]]; then
                        if (( i == 1 )); then
                            step=5 && break
                        elif (( i > 1 )); then
                            params=("${params[@]:0:${#params[@]}-1}") && ((i--))
                        fi
                    elif [[ -n "$input" ]]; then
                        params+=("$input") && ((i++))
                    else
                        echo "Parameter $i is required."
                    fi
                done
                (( i > numParams )) && step=7
                ;;
            7)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$blockchainNetwork")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                [ -n "$contractSpecsId" ] && echo "Contract Specs ID: $contractSpecsId"
                echo "Network: $net_name"
                echo "Method: $method"
                local final_params=$(jq -n '[]')
                parse_structure() {
                    local input="$1"
                    if [[ "$input" =~ ^\[.*\]$ ]]; then
                        local result=$(jq -n '[]') trimmed=$(echo "$input" | sed -E 's/^\[|\]$//g') buffer="" depth=0
                        while IFS= read -r -n1 char; do
                            [[ "$char" == "[" ]] && ((depth++))
                            [[ "$char" == "]" ]] && ((depth--))
                            if [[ "$char" == "," && $depth -eq 0 ]]; then
                                result=$(echo "$result" | jq ". + [$(parse_structure "$buffer")]") && buffer=""
                            else
                                buffer+="$char"
                            fi
                        done <<< "$trimmed"
                        [[ -n "$buffer" ]] && result=$(echo "$result" | jq ". + [$(parse_structure "$buffer")]")
                        echo "$result"
                    elif [[ "$input" =~ ^[0-9]+$|^(true|false)$ ]]; then
                        echo "$input"
                    else
                        echo "\"$input\""
                    fi
                }
                for param in "${params[@]}"; do
                    final_params=$(echo "$final_params" | jq ". + [$(parse_structure "$param")]")
                done
                [[ ${#params[@]} -gt 0 ]] && {
                    local display_params=$(jq -n '[]')
                    for param in "${params[@]}"; do
                        display_params=$(echo "$display_params" | jq ". + [$(parse_structure "$param")]")
                    done
                    display_params=$(echo "$display_params" | jq -r '. | map(
                        if type == "array" or type == "number" or type == "boolean" then tostring else "\"\(.)\"" end
                        ) | join(", ")')
                    echo "Params: [$display_params]"
                }
                echo

                _confirmation && step=0 || { [[ $? -eq 99 ]] && step=5 || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --arg contractSpecsId "$contractSpecsId" \
        --argjson blockchainNetwork "$blockchainNetwork" \
        --arg method "$method" \
        '{
            contractAddress: $contractAddress,
            blockchainNetwork: $blockchainNetwork,
            method: $method
        } +
        (if $contractSpecsId != "" then {contractSpecsId: $contractSpecsId | tonumber} else {} end)')
    data=$(echo "$data" | jq --argjson params "$final_params" '. + {params: $params}')

    local response=$(curl --silent --location --request GET 'https://api.vottun.tech/core/v1/evm/transact/view' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
}

get_nets() { # REQUEST THE LIST OF AVAILABLE BLOCKCHAIN NETWORKS

    echo -e "Retrieving all available blockchain networks...\n"

    curl --location --request GET 'https://api.vottun.tech/core/v1/evm/info/chains' "${auth[@]}"

    echo
}

get_specs() { # REQUEST THE LIST OF AVAILABLE CONTRACT SPECIFICATIONS

    echo -e "Retrieving the info for the shared smart contracts and your own...\n"

    curl --location --request GET 'https://api.vottun.tech/core/v1/evm/info/specs' "${auth[@]}"

    echo
}

query_address(){ # QUERY AN ADDRESS TO DETERMINE IF IT IS A SMART CONTRACT

    local address network step=1

    echo "Please enter the following parameters to find out if the address is a smart contract:"
    echo -e "address network\n"

    while true; do
        case $step in
            1)
                _check_input "Address: " address -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Address is required." "Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Address: $address"
                echo -e "Network: $net_name\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done 

    local response=$(curl --silent --location --request GET \
        'https://api.vottun.tech/core/v1/evm/info/address/'$address'/iscontract?network='$network'' "${auth[@]}")

    echo -e "Server response:\n$response"
}

query_tx(){ # QUERY TRANSACTION INFORMATION FROM THE BLOCKCHAIN

    local txHash network step=1

    echo "Please enter the following parameters to get the transaction information:"
    echo -e "txHash network\n"

    while true; do
        case $step in
            1)
                _check_input "Tx Hash: " txHash -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{64}$ ]]' \
                    "Tx Hash is required." "Tx Hash must start with '0x' and be 66 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Tx Hash: $txHash"
                echo -e "Network: $net_name\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done 

    local response=$(curl --silent --location --request GET \
        'https://api.vottun.tech/core/v1/evm/info/transaction/'$txHash'?network='$network'' "${auth[@]}")

    echo -e "Server response:\n$response"
}

query_status(){ # QUERY THE STATUS OF A TRANSACTION

    local txHash network step=1

    echo "Please enter the following parameters to check the transaction status:"
    echo -e "txHash network\n"

    while true; do
        case $step in
            1)
                _check_input "Tx Hash: " txHash -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{64}$ ]]' \
                    "Tx Hash is required." "Tx Hash must start with '0x' and be 66 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Tx Hash: $txHash"
                echo -e "Network: $net_name\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done 

    local response=$(curl --silent --location --request GET \
        'https://api.vottun.tech/core/v1/evm/info/transaction/'$txHash'/status?network='$network'' "${auth[@]}")

    echo -e "Server response:\n$response"
}

query_ref(){ # QUERY THE STATUS OF A TRANSACTION USING THE CUSTOMER REFERENCE

    local reference

    echo -e "Please enter the following parameter to check the transaction status:\n"

    while true; do 
        _check_input "Reference: " reference -1 "true" 'true' "Reference is required." ""
        [[ $? -eq 99 ]] && continue
                
        echo -e "\nYou've entered the following parameter:\nReference: $reference\n"

        _confirmation && break || [[ $? -eq 99 ]] || return 1
    done

    local response=$(curl --silent --location --request GET \
        'https://api.vottun.tech/core/v1/evm/info/transaction/reference/'$reference'' "${auth[@]}")

    echo -e "Server response:\n$response"
}

query_gas(){ # QUERY THE CURRENT GAS PRICE FOR A SPECIFIED BLOCKCHAIN NETWORK

    local network

    echo -e "Please enter the following parameter to get the current gas price:\n"

    while true; do 
        _check_input "Network: " network -1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
            "Network is required." "Network must be an integer number."
        [[ $? -eq 99 ]] && continue

        IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
        echo -e "\nYou've entered the following parameter:\nNetwork: $net_name\n"

        _confirmation && break || [[ $? -eq 99 ]] || return 1
    done

    local response=$(curl --silent --location --request GET \
        'https://api.vottun.tech/core/v1/evm/network/gasprice?network='$network'' "${auth[@]}")

    echo -e "Server response:\n$response"
}

query_nat(){ # QUERY THE BALANCE OF NATIVE CURRENCY FOR A SPECIFIED ADDRESS

    local address network step=1

    echo "Please enter the following parameters to check the balance of native currency:"
    echo -e "address network\n"

    while true; do
        case $step in
            1)
                _check_input "Address: " address -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Address is required." "Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Network: " network 1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=3
                ;;
            3)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$network")"
                echo -e "\nYou've entered the following parameters:"
                echo "Address: $address"
                echo -e "Network: $net_name\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done 

    local response=$(curl --silent --location --request GET \
        'https://api.vottun.tech/core/v1/evm/chain/'$address'/balance?network='$network'' "${auth[@]}")

    echo -e "Server response:\n$response"
}

gas_deploy() { # ESTIMATE THE GAS REQUIRED FOR A SMART CONTRACT DEPLOYMENT

    local contractSpecsId sender blockchainNetwork numParams params step=1

    echo "Please enter the following parameters to estimate the gas required to deploy a smart contract:"
    echo -e "contractSpecsId sender network params\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Specs ID: " contractSpecsId -1 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Contract Specs ID is required." "Contract Specs ID must be an integer number."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Sender: " sender 1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Sender is required." "Sender must start with '0x' and be 42 characters long."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Network: " blockchainNetwork 2 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "How many parameters do you want to input? " numParams 3 "false" \
                    '[[ "$input" =~ ^[0-9]+$ ]]' "" "Please enter a valid integer."
                _step_back && continue
                numParams=${numParams:-0}
                params=()
                step=5
                ;;
            5)
                local i=1
                while (( i <= numParams )); do
                    read -e -p "Param $i: " input
                    if [[ "$input" =~ ^(<<|\.\.|!undo|!back|!del)$ ]]; then
                        if (( i == 1 )); then
                            step=4 && break
                        elif (( i > 1 )); then
                            params=("${params[@]:0:${#params[@]}-1}") && ((i--))
                        fi
                    elif [[ -n "$input" ]]; then
                        params+=("$input") && ((i++))
                    else
                        echo "Parameter $i is required."
                    fi
                done
                (( i > numParams )) && step=6
                ;;
            6)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$blockchainNetwork")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Specs ID: $contractSpecsId"
                echo "Sender: $sender"
                echo "Network: $net_name"
                local final_params=$(jq -n '[]')
                parse_structure() {
                    local input="$1"
                    if [[ "$input" =~ ^\[.*\]$ ]]; then
                        local result=$(jq -n '[]') trimmed=$(echo "$input" | sed -E 's/^\[|\]$//g') buffer="" depth=0
                        while IFS= read -r -n1 char; do
                            [[ "$char" == "[" ]] && ((depth++))
                            [[ "$char" == "]" ]] && ((depth--))
                            if [[ "$char" == "," && $depth -eq 0 ]]; then
                                result=$(echo "$result" | jq ". + [$(parse_structure "$buffer")]") && buffer=""
                            else
                                buffer+="$char"
                            fi
                        done <<< "$trimmed"
                        [[ -n "$buffer" ]] && result=$(echo "$result" | jq ". + [$(parse_structure "$buffer")]")
                        echo "$result"
                    elif [[ "$input" =~ ^[0-9]+$|^(true|false)$ ]]; then
                        echo "$input"
                    else
                        echo "\"$input\""
                    fi
                }
                for param in "${params[@]}"; do
                    final_params=$(echo "$final_params" | jq ". + [$(parse_structure "$param")]")
                done
                [[ ${#params[@]} -gt 0 ]] && {
                    local display_params=$(jq -n '[]')
                    for param in "${params[@]}"; do
                        display_params=$(echo "$display_params" | jq ". + [$(parse_structure "$param")]")
                    done
                    display_params=$(echo "$display_params" | jq -r '. | map(
                        if type == "array" or type == "number" or type == "boolean" then tostring else "\"\(.)\"" end
                        ) | join(", ")')
                    echo "Params: [$display_params]"
                }
                echo

                _confirmation && step=0 || { [[ $? -eq 99 ]] && step=4 || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --argjson contractSpecsId "$contractSpecsId" \
        --arg sender "$sender" \
        --argjson blockchainNetwork "$blockchainNetwork" \
        '{
            contractSpecsId: $contractSpecsId,
            sender: $sender,
            blockchainNetwork: $blockchainNetwork
        }')
    data=$(echo "$data" | jq --argjson params "$final_params" '. + {params: $params}')

    local response=$(curl --silent --location --request GET \
        'https://api.vottun.tech/core/v1/evm/contract/deploy/estimategas' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
}

gas_tx() { # ESTIMATE THE GAS REQUIRED TO CALL ANY PUBLIC FUNCTION IMPLEMENTED IN A SMART CONTRACT

    local contractAddress sender blockchainNetwork method numParams params value step=1

    echo "Please enter the following parameters to estimate the gas required to call the function:"
    echo -e "contractAddress sender network method params (amount)\n"

    while true; do
        case $step in
            1)
                _check_input "Contract Address: " contractAddress -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Contract Address is required." "Contract Address must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Sender: " sender 1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Sender is required." "Sender must start with '0x' and be 42 characters long."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Network: " blockchainNetwork 2 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Method: " method 3 "true" '[[ "$input" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]' \
                    "Method is required." "Method format is wrong."
                _step_back && continue
                step=5
                ;;
            5)
                _check_input "How many parameters do you want to input? " numParams 4 "false" \
                    '[[ "$input" =~ ^[0-9]+$ ]]' "" "Please enter a valid integer."
                _step_back && continue
                numParams=${numParams:-0}
                params=()
                step=6
                ;;
            6)
                local i=1
                while (( i <= numParams )); do
                    read -e -p "Param $i: " input
                    if [[ "$input" =~ ^(<<|\.\.|!undo|!back|!del)$ ]]; then
                        if (( i == 1 )); then
                            step=5 && break
                        elif (( i > 1 )); then
                            params=("${params[@]:0:${#params[@]}-1}") && ((i--))
                        fi
                    elif [[ -n "$input" ]]; then
                        params+=("$input") && ((i++))
                    else
                        echo "Parameter $i is required."
                    fi
                done
                (( i > numParams )) && step=7
                ;;
            7)
                _check_input "Amount of native tokens (optional): " value 5 "false" \
                    '[[ "$input" =~ ^[0-9]*\.?[0-9]+$ ]]' "" "Amount must be a valid integer or decimal if provided."
                [[ $? -eq 99 ]] && step=5 && continue
                [[ -z "$value" ]] && value=${value:-0}
                value_wei=$(echo "$value * 10^18 / 1" | bc)
                step=8
                ;;
            8)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$blockchainNetwork")"
                echo -e "\nYou've entered the following parameters:"
                echo "Contract Address: $contractAddress"
                echo "Sender: $sender"
                echo "Network: $net_name"
                echo "Method: $method"
                local final_params=$(jq -n '[]')
                parse_structure() {
                    local input="$1"
                    if [[ "$input" =~ ^\[.*\]$ ]]; then
                        local result=$(jq -n '[]') trimmed=$(echo "$input" | sed -E 's/^\[|\]$//g') buffer="" depth=0
                        while IFS= read -r -n1 char; do
                            [[ "$char" == "[" ]] && ((depth++))
                            [[ "$char" == "]" ]] && ((depth--))
                            if [[ "$char" == "," && $depth -eq 0 ]]; then
                                result=$(echo "$result" | jq ". + [$(parse_structure "$buffer")]") && buffer=""
                            else
                                buffer+="$char"
                            fi
                        done <<< "$trimmed"
                        [[ -n "$buffer" ]] && result=$(echo "$result" | jq ". + [$(parse_structure "$buffer")]")
                        echo "$result"
                    elif [[ "$input" =~ ^[0-9]+$|^(true|false)$ ]]; then
                        echo "$input"
                    else
                        echo "\"$input\""
                    fi
                }
                for param in "${params[@]}"; do
                    final_params=$(echo "$final_params" | jq ". + [$(parse_structure "$param")]")
                done
                [[ ${#params[@]} -gt 0 ]] && {
                    local display_params=$(jq -n '[]')
                    for param in "${params[@]}"; do
                        display_params=$(echo "$display_params" | jq ". + [$(parse_structure "$param")]")
                    done
                    display_params=$(echo "$display_params" | jq -r '. | map(
                        if type == "array" or type == "number" or type == "boolean" then tostring else "\"\(.)\"" end
                        ) | join(", ")')
                    echo "Params: [$display_params]"
                }
                [[ -n "$value" && "$value" -gt 0 ]] && echo "Amount of native tokens: $value $currency"
                echo

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg contractAddress "$contractAddress" \
        --arg sender "$sender" \
        --argjson blockchainNetwork "$blockchainNetwork" \
        --arg method "$method" \
        '{
            contractAddress: $contractAddress,
            sender: $sender,
            blockchainNetwork: $blockchainNetwork,
            method: $method
        }')
    [ -n "$value" ] && data=$(echo "$data" | sed "s/^{/{\"value\":$value_wei, /")
    data=$(echo "$data" | jq --argjson params "$final_params" '. + {params: $params}')

    local response=$(curl --silent --location --request GET \
        'https://api.vottun.tech/core/v1/evm/transact/mutable/estimategas' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
}

gas_nat() { # ESTIMATE THE GAS REQUIRED TO TRANSFER NATIVE ASSETS

    local sender recipient blockchainNetwork value step=1

    echo "Please enter the following parameters to estimate the gas required to transfer native assets:"
    echo -e "sender recipient network amount\n"

    while true; do
        case $step in
            1)
                _check_input "Sender: " sender -1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Sender is required." "Sender must start with '0x' and be 42 characters long."
                [[ $? -eq 99 ]] && continue
                step=2
                ;;
            2)
                _check_input "Recipient: " recipient 1 "true" '[[ "$input" =~ ^0x[0-9a-fA-F]{40}$ ]]' \
                    "Recipient is required." "Recipient must start with '0x' and be 42 characters long."
                _step_back && continue
                step=3
                ;;
            3)
                _check_input "Network: " blockchainNetwork 2 "true" '[[ "$input" =~ ^[0-9]+$ ]]' \
                    "Network is required." "Network must be an integer number."
                _step_back && continue
                step=4
                ;;
            4)
                _check_input "Amount: " value 3 "true" '[[ "$input" =~ ^[0-9]*\.?[0-9]+$ ]]' \
                    "Amount is required." "Amount must be a valid integer or decimal."
                _step_back && continue
                value_wei=$(echo "$value * 10^18 / 1" | bc)
                step=5
                ;;
            5)
                IFS='|' read -r net_name currency url_address url_tx <<< "$(_network_details "$blockchainNetwork")"
                echo -e "\nYou've entered the following parameters:"
                echo "Sender: $sender"
                echo "Recipient: $recipient"
                echo "Network: $net_name"
                echo -e "Amount: $value $currency\n"

                _confirmation && step=0 || { _step_back || return 1; }
                [[ $step -eq 0 ]] && break
                ;;
        esac
    done

    local data=$(jq -n \
        --arg sender "$sender" \
        --arg recipient "$recipient" \
        --argjson blockchainNetwork "$blockchainNetwork" \
        '{
            sender: $sender,
            recipient: $recipient,
            blockchainNetwork: $blockchainNetwork,
        }')
    data=$(echo "$data" | sed "s/^{/{\"value\":$value_wei, /")

    local response=$(curl --silent --location --request GET \
        'https://api.vottun.tech/core/v1/evm/chain/transfer/estimategas' \
        "${auth[@]}" $ct_json --data-raw "$data")

    echo -e "Server response:\n$response"
}
